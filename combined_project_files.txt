
--- START FILE: combine_project.py ---

import os

def combine_files_to_single_file(root_dir, output_filename="combined_project_files.txt"):
    """
    Combines the content of all files in a directory into a single file,
    excluding 'node_modules' directories and 'package-lock.json' files.

    Args:
        root_dir (str): The root directory of the project.
        output_filename (str): The name of the output file.
    """
    combined_content = []
    excluded_dirs = ['node_modules', '.git', '.vscode', '.idea', 'dist', 'build']
    excluded_files = ['package-lock.json', 'yarn.lock', 'bun.lockb', '.env', 'xlsx.full.min.js'] # Added .env as it might contain sensitive info

    print(f"Starting to combine files from: {root_dir}")
    print(f"Excluding directories: {excluded_dirs}")
    print(f"Excluding files: {excluded_files}")

    for dirpath, dirnames, filenames in os.walk(root_dir):
        # Modify dirnames in-place to skip excluded directories
        dirnames[:] = [d for d in dirnames if d not in excluded_dirs]

        for filename in filenames:
            if filename in excluded_files:
                print(f"Skipping excluded file: {os.path.join(dirpath, filename)}")
                continue

            file_path = os.path.join(dirpath, filename)
            # Make path relative to root_dir for the header
            relative_file_path = os.path.relpath(file_path, root_dir)

            try:
                with open(file_path, 'r', encoding='utf-8') as f:
                    content = f.read()
                
                combined_content.append(f"\n--- START FILE: {relative_file_path} ---\n\n")
                combined_content.append(content)
                combined_content.append(f"\n\n--- END FILE: {relative_file_path} ---\n")
                print(f"Included file: {relative_file_path}")
            except UnicodeDecodeError:
                print(f"Skipping binary or undecodable file (UnicodeDecodeError): {relative_file_path}")
            except Exception as e:
                print(f"Error reading file {relative_file_path}: {e}")

    output_path = os.path.join(root_dir, output_filename)
    try:
        with open(output_path, 'w', encoding='utf-8') as outfile:
            outfile.write("".join(combined_content))
        print(f"\nSuccessfully combined all files into: {output_path}")
    except Exception as e:
        print(f"Error writing output file {output_path}: {e}")

if __name__ == "__main__":
    # Get the current working directory where the script is run
    # This assumes you run the script from your project's root directory
    project_root = os.getcwd()
    combine_files_to_single_file(project_root)


--- END FILE: combine_project.py ---

--- START FILE: content.js ---

/**
 * content.js
 * This script runs in the context of the web page.
 * It listens for messages from the extension's popup and performs DOM manipulations.
 */

// Global flag to ensure message listener is added only once per script execution context
// This helps prevent stacking listeners if the content script is executed multiple times
// without the page fully reloading.
let listenerInitialized = false;

// Global error handler for better debugging in the content script context
window.onerror = function (msg, url, lineNo, columnNo, error) {
    console.error('Global Error (content.js):', { msg, url, lineNo, columnNo, error });
    // In a production extension, you might send this error to a background script or a logging service.
};

// Listen for messages from the popup script
// This listener will only be added once due to the listenerInitialized check
if (!listenerInitialized) {
    chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
        // Handle a 'ping' action to confirm the content script is loaded
        if (request.action === "ping") {
            sendResponse({ status: "pong" });
            return true; // Indicate that the response will be sent asynchronously
        }
        else if (request.action === 'scanFields') {
            const fields = scanForFormFields();
            sendResponse({ fields: fields });
            return true; // Keep the message channel open for async response
        } else if (request.action === 'fillBatch') { // Handle batched filling
            const { dataBatch, fillEmptyOnly } = request;
            const result = fillFormFieldsBatch(dataBatch, fillEmptyOnly);
            sendResponse(result);
            return true; // Keep the message channel open for async response
        } else if (request.action === "scanClickables") { // Handle scanClickables
            const elements = getClickableElements();
            sendResponse({ clickables: elements });
            return true; // Keep the message channel open for async response
        } else if (request.action === "performClick") { // Handle performClick
            // Call the async function and then send the response
            clickElementByStableId(request.stableId, request.count).then(result => {
                sendResponse({
                    status: result.success ? "success" : "error",
                    message: result.message || ""
                });
            }).catch(error => {
                console.error("Error in performClick promise chain:", error);
                sendResponse({ status: "error", message: `Internal error during click: ${error.message}` });
            });
            return true; // This is crucial: indicates that sendResponse will be called asynchronously
        }
        // If no action matched, return false or nothing for synchronous handling
        return false;
    });
    listenerInitialized = true; // Set flag to true after listener is added
}


/**
 * Scans the current web page for input fields, textareas, and select elements.
 * Gathers relevant information about each field, including enhanced metadata and a grouping context.
 * @returns {Array<Object>} An array of objects, each representing a form field.
 */
function scanForFormFields() {
    const fields = [];
    // Select all relevant form elements, excluding hidden, submit, button, and reset types.
    const elements = document.querySelectorAll('input:not([type="hidden"]):not([type="submit"]):not([type="button"]):not([type="reset"]), textarea, select');

    elements.forEach((element, index) => {
        // Generate a more stable and readable ID if the element doesn't have one.
        // Prioritize existing ID, then name, then placeholder, then a generated stable ID.
        let fieldId = element.id || element.name || element.placeholder || `stable-id-${index}-${Date.now()}`;
        // Ensure the ID is unique and valid for DOM selection
        if (!element.id) {
            // Make sure the generated ID is unique on the page if it's not already
            let tempId = fieldId;
            let counter = 0;
            while (document.getElementById(tempId)) {
                tempId = `${fieldId}-${counter++}`;
            }
            element.id = tempId; // Assign the unique ID to the DOM element
            fieldId = tempId; // Use this new unique ID for our field object
        }

        let labelText = '';

        // --- Prioritize table headers (<th>) for fields inside table cells (<td>) ---
        let currentCell = element.closest('td');
        if (currentCell) {
            const table = currentCell.closest('table');
            if (table) {
                const cellIndex = Array.from(currentCell.parentElement.children).indexOf(currentCell);
                // Try to find a corresponding <th> in the same column within the table's thead
                const headerCell = table.querySelector(`thead tr th:nth-child(${cellIndex + 1})`);
                if (headerCell && headerCell.textContent.trim().length > 0) {
                    labelText = headerCell.textContent.trim();
                }
            }
        }

        // Prioritize more direct and semantic labels if table header not found or empty
        if (!labelText) {
            if (element.getAttribute('aria-label')) {
                labelText = element.getAttribute('aria-label').trim();
            } else if (element.placeholder) {
                labelText = element.placeholder.trim();
            } else if (element.title) {
                labelText = element.title.trim();
            } else if (element.name) {
                // Clean up name attribute if it contains array-like indexing
                labelText = element.name.replace(/\[\d+\]/g, '').trim();
            }
        }

        // Fallback to finding an associated label using 'for' attribute
        if (!labelText && element.id) {
            const label = document.querySelector(`label[for="${element.id}"]`);
            if (label) {
                labelText = label.textContent.trim();
            }
        }

        // If no 'for' label, check parent elements for label text or aria-label
        if (!labelText) {
            let parent = element.parentElement;
            while (parent && parent.tagName !== 'BODY') {
                // Check for a <label> element that contains the current element
                const potentialLabel = parent.querySelector(`label:has(#${element.id})`); // Using :has() for more accurate containment
                if (potentialLabel) {
                    labelText = potentialLabel.textContent.trim();
                    break;
                }
                // Check for a label or text directly within the parent that might serve as a label
                const parentText = Array.from(parent.childNodes)
                    .filter(node => node.nodeType === Node.TEXT_NODE && node.textContent.trim().length > 0)
                    .map(node => node.textContent.trim())
                    .join(' ');
                if (parentText) {
                    labelText = parentText;
                    break;
                }
                parent = parent.parentElement;
            }
        }
        
        // --- Collect more metadata for intelligent auto-mapping and grouping context ---
        let surroundingText = '';

        // Prioritize text from immediate previous sibling elements that might be headings or prominent labels
        let prevSibling = element.previousElementSibling;
        while (prevSibling && (prevSibling.tagName === 'LABEL' || prevSibling.tagName === 'P' || prevSibling.tagName === 'DIV' || prevSibling.tagName.match(/^H[1-6]$/))) {
            const text = prevSibling.textContent.trim();
            if (text.length > 0) {
                surroundingText = text + ' ' + surroundingText;
            }
            // Stop if we hit a non-text/label/heading element or a form boundary
            if (!prevSibling.previousElementSibling || prevSibling.previousElementSibling.tagName === 'FORM' || prevSibling.previousElementSibling.tagName === 'fieldset' || prevSibling.previousElementSibling.tagName === 'SECTION') {
                break;
            }
            prevSibling = prevSibling.previousElementSibling;
        }

        // Also check parent elements for prominent text/labels, especially for table headers (re-check if not already found)
        if (!surroundingText && currentCell) { // Only if we are in a table cell and surroundingText is still empty
            const table = currentCell.closest('table');
            if (table) {
                const cellIndex = Array.from(currentCell.parentElement.children).indexOf(currentCell);
                const headerCell = table.querySelector(`thead tr th:nth-child(${cellIndex + 1})`);
                if (headerCell && headerCell.textContent.trim().length > 0) {
                    surroundingText = headerCell.textContent.trim();
                }
            }
        }

        // Check for general parent text/labels if still no strong context
        let currentParent = element.parentElement;
        while (currentParent && currentParent.tagName !== 'BODY') {
            const parentLabel = currentParent.querySelector('label');
            if (parentLabel && parentLabel.textContent.trim().length > 0 && !surroundingText.includes(parentLabel.textContent.trim())) {
                surroundingText = parentLabel.textContent.trim() + ' ' + surroundingText;
            }

            const parentHeading = currentParent.querySelector('h1, h2, h3, h4, h5, h6');
            if (parentHeading && parentHeading.textContent.trim().length > 0 && !surroundingText.includes(parentHeading.textContent.trim())) {
                surroundingText = parentHeading.textContent.trim() + ' ' + surroundingText;
            }

            Array.from(currentParent.childNodes).forEach(node => {
                if (node.nodeType === Node.TEXT_NODE && node.textContent.trim().length > 0 && !surroundingText.includes(node.textContent.trim())) {
                    surroundingText += node.textContent.trim() + ' ';
                }
            });

            currentParent = currentParent.parentElement;
        }
        surroundingText = surroundingText.trim();

        // Fallback to labelText if surroundingText is still empty
        if (!surroundingText && labelText) {
            surroundingText = labelText;
        }
        // Fallback to placeholder if still no context
        if (!surroundingText && element.placeholder) {
            surroundingText = element.placeholder.trim();
        }
        // Fallback to name if still no context
        if (!surroundingText && element.name) {
            surroundingText = element.name.trim();
        }

        fields.push({
            id: fieldId, // Internal unique ID for the element (now more stable)
            name: element.name || '',
            type: element.type || element.tagName.toLowerCase(),
            value: element.value || '', // Current value of the field
            labelText: labelText, // Best guess for a user-friendly label
            htmlId: element.id, // Explicitly store the ID
            placeholder: element.placeholder || '',
            ariaLabel: element.getAttribute('aria-label') || '',
            className: element.className || '', // All classes as a string
            dataset: element.dataset ? JSON.parse(JSON.stringify(element.dataset)) : {}, // Convert DOMStringMap to plain object
            surroundingText: surroundingText, // This will now be our primary grouping key
            autocomplete: element.getAttribute('autocomplete') || '', // HTML autocomplete attribute
            role: element.getAttribute('role') || '', // ARIA role attribute
            title: element.getAttribute('title') || '' // HTML title attribute
        });
    });
    return fields;
}

/**
 * Fills a batch of specified form fields with data.
 * @param {Array<Object>} dataBatch - An array of objects, where each object is { fieldId: valueToFill }.
 * @param {boolean} fillEmptyOnly - If true, only fill fields that are currently empty.
 * @returns {Object} An object with status, filled count, and skipped count.
 */
function fillFormFieldsBatch(dataBatch, fillEmptyOnly) {
    let filledCount = 0;
    let skippedCount = 0;

    dataBatch.forEach(fieldData => {
        const fieldId = fieldData.id; // Use 'id' as the key for the field element
        const valueToFill = fieldData.value; // Use 'value' as the value to fill

        const element = document.getElementById(fieldId);

        if (element) {
            const currentFieldValue = element.value;

            // Check if the field should be skipped based on fillEmptyOnly flag
            if (fillEmptyOnly && currentFieldValue.trim() !== '') {
                skippedCount++;
                return; // Continue to the next item in the batch
            }

            // Fill the field based on its type
            if (element.tagName === 'INPUT' || element.tagName === 'TEXTAREA') {
                element.value = valueToFill;
                // Dispatch input/change events to trigger any framework listeners
                element.dispatchEvent(new Event('input', { bubbles: true }));
                element.dispatchEvent(new Event('change', { bubbles: true }));
                filledCount++;
            } else if (element.tagName === 'SELECT') {
                // For select elements, try to find an option with the matching value
                let optionFound = false;
                for (let i = 0; i < element.options.length; i++) {
                    // Match by value or by text content
                    if (element.options[i].value === valueToFill || element.options[i].textContent === valueToFill) {
                        element.value = element.options[i].value;
                        optionFound = true;
                        break;
                    }
                }
                if (optionFound) {
                    element.dispatchEvent(new Event('change', { bubbles: true }));
                    filledCount++;
                } else {
                    console.warn(`Select element with ID "${fieldId}" has no option for value "${valueToFill}".`);
                    skippedCount++; // Consider this skipped if value not found
                }
            } else {
                console.warn(`Unsupported field type for element with ID "${fieldId}".`);
                skippedCount++;
            }
        } else {
            console.warn(`Element with ID "${fieldId}" not found on the page.`);
            skippedCount++;
        }
    });

    return { status: 'success', filledCount: filledCount, skippedCount: skippedCount };
}

/**
 * Scans the current web page for clickable elements.
 * @returns {Array<Object>} An array of objects, each representing a clickable element.
 */
function getClickableElements() {
    // Select common clickable elements: buttons, input type="button", links with href, and elements with role="button"
    const buttons = [...document.querySelectorAll('button, input[type="button"], a[href], [role="button"], [onclick], [tabindex="0"][aria-pressed], [tabindex="0"][aria-expanded], [tabindex="0"][role]:not([role="textbox"]):not([role="searchbox"]):not([role="combobox"]):not([role="slider"])')];
    
    // Filter out hidden elements, and elements that are likely part of other controls (like text inputs within a search button container)
    const filteredButtons = buttons.filter(el => {
        const style = window.getComputedStyle(el);
        const isVisible = style.display !== 'none' && style.visibility !== 'hidden' && style.opacity !== '0';
        const rect = el.getBoundingClientRect();
        const hasSize = rect.width > 0 && rect.height > 0;
        
        // Exclude elements that are disabled or have a disabled attribute
        if (el.disabled || el.getAttribute('aria-disabled') === 'true') {
            return false;
        }

        // Exclude inputs that are not explicitly buttons
        if (el.tagName === 'INPUT' && el.type !== 'button' && el.type !== 'submit' && el.type !== 'reset') {
            return false;
        }

        // Exclude links that are just anchors with no real action (e.g., # or javascript:void(0))
        if (el.tagName === 'A' && (!el.href || el.href.trim() === '#' || el.href.startsWith('javascript:void(0)'))) {
            return false;
        }

        return isVisible && hasSize;
    });

    return filteredButtons.map((el, index) => {
        // Prefer text content, then aria-label, then title for a human-readable label
        const text = el.innerText?.trim() || "";
        const aria = el.getAttribute("aria-label")?.trim() || "";
        const title = el.getAttribute("title")?.trim() || "";
        const name = el.getAttribute("name")?.trim() || "";
        const id = el.id?.trim() || "";

        let label = text || aria || title || name || id || `Element #${index + 1}`;
        if (label.length > 50) { // Truncate long labels for display
            label = label.substring(0, 47) + '...';
        }

        // Generate a stable ID for the element if it doesn't have one or if it's not unique
        let stableId = el.id || `autoClick-${index}-${Date.now()}`;
        if (!el.id) {
            // Ensure generated ID is unique on the page
            let tempId = stableId;
            let counter = 0;
            while (document.getElementById(tempId)) {
                tempId = `${stableId}-${counter++}`;
            }
            el.id = tempId; // Assign the generated ID to the element for easier future lookup
            stableId = tempId;
        }
        
        // Add a data attribute for easier direct selection in the content script
        // This ensures a stable way to find the element even if its original ID is dynamically changed
        el.setAttribute("data-auto-click-id", stableId);

        return { text: label, stableId: stableId }; // Return the chosen label and stable ID
    });
}

/**
 * Performs a click on an element identified by its stable ID, with a delay between clicks.
 * @param {string} stableId - The stable ID of the element to click.
 * @param {number} count - The number of times to click the element.
 * @returns {Promise<Object>} A promise that resolves to an object indicating success or failure and a message.
 */
async function clickElementByStableId(stableId, count) {
    // Select using the data-auto-click-id attribute which we assigned
    const target = document.querySelector(`[data-auto-click-id="${stableId}"]`);
    
    if (!target) {
        return { success: false, message: "Target element not found on the page. It might have been removed or changed." };
    }

    try {
        for (let i = 0; i < count; i++) {
            target.click(); // Programmatically perform the click event
            // Introduce a short delay to simulate human interaction and allow DOM to react
            await new Promise(resolve => setTimeout(resolve, 300)); // 300ms delay between clicks
        }
        return { success: true };
    } catch (error) {
        console.error("Error simulating click:", error);
        return { success: false, message: `Error during click simulation: ${error.message}` };
    }
}


--- END FILE: content.js ---

--- START FILE: manifest.json ---

{
    "manifest_version": 3,
    "name": "Spreadsheet Data Filler",
    "version": "1.0",
    "description": "Upload a spreadsheet, map columns to fields on the current tab, and fill them.",
    "permissions": [
        "activeTab",
        "scripting"
    ],
    "action": {
        "default_popup": "popup.html",
        "default_icon": {
            "16": "icons/icon16.png",
            "48": "icons/icon48.png",
            "128": "icons/icon128.png"
        }
    },
    "icons": {
        "16": "icons/icon16.png",
        "48": "icons/icon48.png",
        "128": "icons/icon128.png"
    },
    "web_accessible_resources": [
        {
            "resources": [ "icons/*.png", "xlsx.full.min.js" ],
            "matches": [ "<all_urls>" ]
        }
    ]
}


--- END FILE: manifest.json ---

--- START FILE: popup.css ---

/* popup.css */

/* Define CSS Variables for theming (Light and Dark Mode) */
:root {
  /* Light Mode Colors */
  --bg-color-light: #f9fafb; /* gray-50 */
  --text-color-light: #1f2937; /* Dark gray */
  --header-text-color-light: #111827; /* Darker gray */
  --card-bg-light: #ffffff; /* White */
  --border-color-light: #e5e7eb; /* Light border */

  /* Primary Action Button (Blue) */
  --primary-button-bg-light: #2563eb; /* blue-600 */
  --primary-button-hover-bg-light: #1d4ed8; /* blue-700 */
  --primary-button-shadow-light: 37, 99, 235; /* RGB for blue-600 */

  /* Secondary Action Button (Emerald for Scan, gray for general secondary) */
  --secondary-button-bg-light: #6b7280; /* gray-500 */
  --secondary-button-hover-bg-light: #4b5563; /* gray-600 */
  
  --emerald-button-bg-light: #059669; /* emerald-600 */
  --emerald-button-hover-bg-light: #047857; /* emerald-700 */
  --emerald-button-shadow-light: 5, 150, 105; /* RGB for emerald-600 */

  --input-border-light: #d1d5db; /* gray-300 */
  --input-focus-ring-light: #60a5fa; /* blue-400 */
  --input-focus-ring-rgb-values-light: 96, 165, 250;

  /* Drop Area */
  --drop-area-border-light: #60a5fa; /* blue-400 */
  --drop-area-bg-light: #eff6ff; /* blue-50 */
  --drop-area-hover-bg-light: #dbeafe; /* blue-100 */
  --drop-area-text-light: #6b7280; /* gray-500 */
  --drop-area-hover-text-light: #1e40af; /* blue-800 */
  
  /* File Status Message */
  --file-status-success-bg-light: #d1fae5; /* green-100 */
  --file-status-success-border-light: #34d399; /* green-400 */
  --file-status-success-text-light: #065f46; /* green-700 */
  --file-status-success-icon-light: #10b981; /* green-500 */

  --file-status-error-bg-light: #fee2e2; /* red-100 */
  --file-status-error-border-light: #f87171; /* red-400 */
  --file-status-error-text-light: #991b1b; /* red-700 */
  --file-status-error-icon-light: #ef4444; /* red-500 */

  --file-status-info-bg-light: #e0f2fe; /* blue-100 */
  --file-status-info-border-light: #60a5fa; /* blue-400 */
  --file-status-info-text-light: #1e40af; /* blue-700 */
  --file-status-info-icon-light: #3b82f6; /* blue-500 */

  /* Headers List Badges */
  --header-badge-bg-light: #e0e7ff; /* indigo-100 */
  --header-badge-text-light: #3730a3; /* indigo-800 */
  --header-badge-hover-bg-light: #c7d2fe; /* indigo-200 */
  
  /* Auto-Mapped Badges */
  --auto-mapped-learned-bg: #bfdbfe; /* blue-200 */
  --auto-mapped-learned-text: #1e40af; /* blue-800 */
  --auto-mapped-fuzzy-bg: #d1fae5; /* green-200 */
  --auto-mapped-fuzzy-text: #065f46; /* green-800 */
  --auto-mapped-unmapped-bg: #e5e7eb; /* gray-200 */
  --auto-mapped-unmapped-text: #4b5563; /* gray-800 */

  /* Tab Buttons */
  --tab-button-bg: #e5e7eb; /* gray-200 */
  --tab-button-hover-bg: #d1d5db; /* gray-300 */
  --tab-button-active-bg: #ffffff;
  --tab-button-active-text: #2563eb; /* blue-600 */
  --tab-button-text: #4b5563; /* gray-700 */
  
  /* Clickable Elements List */
  --clickable-container-bg: #f9fafb; /* gray-50 */
  --clickable-item-border: #e5e7eb; /* gray-200 */
  --clickable-item-hover-bg: #f3f4f6; /* gray-100 */
  --selected-button-highlight-bg: #e0f2fe; /* blue-100 */
  --selected-button-highlight-border: #93c5fd; /* blue-300 */
}

/* Dark Mode Overrides (Default Light Mode values are above) */
body.dark {
  --bg-color-dark: #1f2937; /* gray-800 */
  --text-color-dark: #e5e7eb; /* Light gray */
  --header-text-color-dark: #f8fafc; /* White */
  --card-bg-dark: #2d3748; /* Darker card */
  --border-color-dark: #4a5568; /* Dark border */

  --primary-button-bg-dark: #4f46e5; /* indigo-600 */
  --primary-button-hover-bg-dark: #4338ca; /* indigo-700 */
  --primary-button-shadow-dark: 79, 70, 229; /* RGB for indigo-600 */

  --secondary-button-bg-dark: #4a5568; /* gray-700 */
  --secondary-button-hover-bg-dark: #616e80; /* gray-600 */
  
  --emerald-button-bg-dark: #065f46; /* emerald-800 */
  --emerald-button-hover-bg-dark: #047857; /* emerald-700 */
  --emerald-button-shadow-dark: 6, 95, 70; /* RGB for emerald-800 */

  --input-border-dark: #4a5568; /* gray-700 */
  --input-focus-ring-dark: #818cf8; /* indigo-400 */
  --input-focus-ring-rgb-values-dark: 129, 140, 248;

  --drop-area-border-dark: #6366f1; /* indigo-500 */
  --drop-area-bg-dark: #3730a3; /* indigo-900 */
  --drop-area-hover-bg-dark: #4f46e5; /* indigo-700 */
  --drop-area-text-dark: #a0aec0; /* gray-400 */
  --drop-area-hover-text-dark: #e0e7ff; /* indigo-100 */

  --file-status-success-bg-dark: #065f46; /* green-900 */
  --file-status-success-border-dark: #34d399; /* green-400 */
  --file-status-success-text-dark: #d1fae5; /* green-100 */
  --file-status-success-icon-dark: #10b981; /* green-500 */

  --file-status-error-bg-dark: #7f1d1d; /* red-900 */
  --file-status-error-border-dark: #f87171; /* red-400 */
  --file-status-error-text-dark: #fee2e2; /* red-100 */
  --file-status-error-icon-dark: #ef4444; /* red-500 */

  --file-status-info-bg-dark: #1e3a8a; /* blue-900 */
  --file-status-info-border-dark: #60a5fa; /* blue-400 */
  --file-status-info-text-dark: #e0f2fe; /* blue-100 */
  --file-status-info-icon-dark: #3b82f6; /* blue-500 */

  --header-badge-bg-dark: #4338ca; /* indigo-700 */
  --header-badge-text-dark: #e0e7ff; /* indigo-100 */
  --header-badge-hover-bg-dark: #4f46e5; /* indigo-600 */

  --auto-mapped-learned-bg: #4c51bf; /* indigo-700 */
  --auto-mapped-learned-text: #e0e7ff; /* indigo-100 */
  --auto-mapped-fuzzy-bg: #14532d; /* green-900 */
  --auto-mapped-fuzzy-text: #dcfce7; /* green-100 */
  --auto-mapped-unmapped-bg: #4a5568; /* gray-700 */
  --auto-mapped-unmapped-text: #a0aec0; /* gray-400 */

  --tab-button-bg-dark: #2d3748; /* gray-800 */
  --tab-button-hover-bg-dark: #4a5568; /* gray-700 */
  --tab-button-active-bg-dark: #6366f1; /* indigo-500 */
  --tab-button-active-text-dark: #ffffff;
  --tab-button-text-dark: #e2e8f0; /* gray-200 */
  
  --clickable-container-bg: #2d3748; /* gray-800 */
  --clickable-item-border: #4a5568; /* gray-700 */
  --clickable-item-hover-bg: #4a5568; /* gray-700 */
  --selected-button-highlight-bg: #4f46e5; /* indigo-600 */
  --selected-button-highlight-border: #a5b4fc; /* indigo-300 */
}

/* Base styles for the body, applied in light mode by default */
body {
    font-family: 'Inter', sans-serif;
    background-color: var(--bg-color-light);
    color: var(--text-color-light);
    transition: background-color 0.3s ease, color 0.3s ease;
    box-sizing: border-box;
    min-width: 320px; /* Ensure a minimum width for small screens */
    /* Prevent scrollbars for the main content unless needed */
    overflow-x: hidden;
}

/* Explicitly hide the default file input */
#fileInput {
    display: none !important;
}

/* Main Container styling */
.main-container {
    padding: 1.5rem; /* Generous padding */
    background-color: var(--card-bg-light);
    border-radius: 0.75rem; /* Rounded corners */
    box-shadow: 0 6px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); /* Prominent shadow */
    position: relative; /* For theme switch positioning */
    transition: background-color 0.3s ease, box-shadow 0.3s ease, border-color 0.3s ease;
}

/* Section and Card Headings */
.section-heading, .card-heading {
    color: var(--header-text-color-light);
    border-color: var(--border-color-light);
    transition: color 0.3s ease, border-color 0.3s ease;
}

/* Card Styling */
.card {
    background-color: var(--card-bg-light);
    padding: 1.25rem; /* Generous padding */
    border: 1px solid var(--border-color-light);
    border-radius: 0.75rem;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.08); /* Stronger shadow for cards */
    margin-bottom: 1.5rem; /* Space between cards */
    transition: background-color 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease;
}

/* Generic Action Button Styling */
.action-button {
    display: flex; /* Flexbox for icon and text alignment */
    align-items: center;
    justify-content: center;
    padding: 0.75rem 1.75rem; /* Adjusted padding */
    border-radius: 9999px; /* Fully rounded (pill shape) */
    font-weight: 600;
    transition: background-color 0.3s ease, transform 0.1s ease, box-shadow 0.3s ease;
    border: none;
    cursor: pointer;
    font-size: 1rem;
    line-height: 1.5rem;
    box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06); /* Subtle shadow */
    outline: none; /* Remove default focus outline */
}
.action-button:hover {
    transform: translateY(-1px); /* Slight lift effect */
    box-shadow: 0 6px 10px -2px rgba(0, 0, 0, 0.15), 0 3px 6px -2px rgba(0, 0, 0, 0.08);
}
.action-button:active {
    transform: translateY(0); /* Press down effect */
    box-shadow: 0 2px 4px -1px rgba(0, 0, 0, 0.1), 0 1px 2px -1px rgba(0, 0, 0, 0.06);
}
.action-button:focus-visible {
    /* Custom focus ring for accessibility using CSS variables */
    box-shadow: 0 0 0 4px rgba(var(--focus-ring-color-rgb), 0.5), 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
}

/* Specific button colors (light mode) */
.action-button.primary {
    background-color: var(--primary-button-bg-light);
    color: #fff;
    --focus-ring-color-rgb: var(--primary-button-shadow-light);
}
.action-button.primary:hover {
    background-color: var(--primary-button-hover-bg-light);
}

.action-button.emerald {
    background-color: var(--emerald-button-bg-light);
    color: #fff;
    --focus-ring-color-rgb: var(--emerald-button-shadow-light);
}
.action-button.emerald:hover {
    background-color: var(--emerald-button-hover-bg-light);
}

.action-button.secondary {
    background-color: var(--secondary-button-bg-light);
    color: #fff; /* White text for better contrast on gray */
    box-shadow: 0 2px 4px -1px rgba(0, 0, 0, 0.05); /* Lighter shadow */
    --focus-ring-color-rgb: 107, 114, 128; /* gray-500 RGB */
}
.action-button.secondary:hover {
    background-color: var(--secondary-button-hover-bg-light);
}

/* Form Input Styling */
.form-input {
    border: 1px solid var(--input-border-light);
    border-radius: 0.5rem; /* Rounded corners */
    padding: 0.625rem 1rem;
    width: 100%;
    background-color: var(--card-bg-light); /* Consistent with card background */
    color: var(--text-color-light);
    transition: border-color 0.2s ease, box-shadow 0.2s ease;
    -webkit-appearance: none; /* Remove default browser styling */
    -moz-appearance: none;
    appearance: none;
}
.form-input:focus {
    border-color: var(--input-focus-ring-light);
    outline: none;
    box-shadow: 0 0 0 3px rgba(var(--input-focus-ring-rgb-values-light), 0.3); /* Custom focus ring */
}

/* File Drop Area Styling */
.drop-area {
    border: 2px dashed var(--drop-area-border-light);
    border-radius: 0.75rem;
    padding: 2rem;
    text-align: center;
    background-color: var(--drop-area-bg-light);
    transition: background-color 0.3s ease, border-color 0.3s ease, color 0.3s ease;
    cursor: pointer;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: 10rem;
}
.drop-area:hover {
    background-color: var(--drop-area-hover-bg-light);
    border-color: var(--primary-button-bg-light); /* Highlight border on hover */
}
.drop-area p {
    color: var(--drop-area-text-light);
    margin-bottom: 1rem;
    font-size: 1.125rem;
    font-weight: 500;
}
.drop-area:hover p {
    color: var(--drop-area-hover-text-light);
}
.browse-button {
    display: inline-block;
    background-color: var(--primary-button-bg-light);
    color: #fff;
    padding: 0.85rem 2rem;
    border-radius: 9999px;
    font-size: 1.125rem;
    font-weight: 600;
    box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
    transition: background-color 0.3s ease, box-shadow 0.3s ease;
    cursor: pointer;
}
.browse-button:hover {
    background-color: var(--primary-button-hover-bg-light);
    box-shadow: 0 6px 10px -2px rgba(0, 0, 0, 0.15), 0 3px 6px -2px rgba(0, 0, 0, 0.08);
}

/* File Status Message Styling */
.file-status {
    padding: 0.875rem 1.25rem;
    border-radius: 0.625rem;
    font-size: 0.95rem;
    font-weight: 500;
    line-height: 1.4;
    display: flex;
    align-items: center;
    transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
}
.file-status.message-success {
    background-color: var(--file-status-success-bg-light);
    border: 1px solid var(--file-status-success-border-light);
    color: var(--file-status-success-text-light);
}
.file-status.message-success #fileStatusIcon {
    color: var(--file-status-success-icon-light);
}
.file-status.message-error {
    background-color: var(--file-status-error-bg-light);
    border: 1px solid var(--file-status-error-border-light);
    color: var(--file-status-error-text-light);
}
.file-status.message-error #fileStatusIcon {
    color: var(--file-status-error-icon-light);
}
.file-status.message-info {
    background-color: var(--file-status-info-bg-light);
    border: 1px solid var(--file-status-info-border-light);
    color: var(--file-status-info-text-light);
}
.file-status.message-info #fileStatusIcon {
    color: var(--file-status-info-icon-light);
}

/* Headers List Styling (Badges) */
.headers-list {
    display: flex;
    flex-wrap: wrap;
    gap: 0.75rem; /* Space between headers */
    margin-bottom: 2rem;
}
.headers-list span {
    background-color: var(--header-badge-bg-light);
    color: var(--header-badge-text-light);
    padding: 0.6rem 1.25rem;
    border-radius: 9999px;
    font-size: 0.95rem;
    font-weight: 500;
    box-shadow: 0 1px 2px rgba(0,0,0,0.05); /* Subtle shadow */
    transition: background-color 0.2s ease, box-shadow 0.2s ease;
    display: flex;
    align-items: center;
    cursor: default;
}
.headers-list span:hover {
    background-color: var(--header-badge-hover-bg-light);
}

/* Checkbox/Radio Labels (Custom appearance) */
.checkbox-label, .radio-label {
    display: flex;
    align-items: center;
    cursor: pointer;
    color: var(--text-color-light);
}
.checkbox-label input[type="checkbox"], .radio-label input[type="radio"] {
    height: 1.125rem;
    width: 1.125rem;
    border: 1px solid var(--input-border-light);
    border-radius: 0.25rem; /* For checkboxes */
    background-color: var(--card-bg-light);
    transition: background-color 0.2s ease, border-color 0.2s ease;
    -webkit-appearance: none;
    -moz-appearance: none;
    appearance: none;
    flex-shrink: 0;
    margin-right: 0.5rem;
}
.checkbox-label input[type="checkbox"]:checked, .radio-label input[type="radio"]:checked {
    background-color: var(--primary-button-bg-light); /* Use primary color when checked */
    border-color: var(--primary-button-bg-light);
    position: relative;
}
.checkbox-label input[type="checkbox"]:checked::after {
    content: '\2713'; /* Checkmark unicode character */
    font-size: 0.75rem;
    color: white;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
}
.radio-label input[type="radio"] {
    border-radius: 50%; /* Make radio buttons round */
}
.radio-label input[type="radio"]:checked::after {
    content: '';
    width: 0.5rem;
    height: 0.5rem;
    background-color: white;
    border-radius: 50%;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
}
.checkbox-label input[type="checkbox"]:focus, .radio-label input[type="radio"]:focus {
    outline: none;
    box-shadow: 0 0 0 3px rgba(var(--input-focus-ring-rgb-values-light), 0.3);
}

/* General Message Boxes (info, success, error) */
.message-box {
    padding: 0.875rem 1rem;
    border-radius: 0.5rem;
    font-size: 0.9rem;
    font-weight: 500;
    line-height: 1.4;
    display: flex;
    align-items: center;
    margin-top: 1rem;
    transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
}
.message-box i {
    margin-right: 0.75rem;
    font-size: 1.1rem;
}
.message-success {
    background-color: #d1fae5; /* green-100 */
    border-left: 4px solid #10b981; /* green-600 */
    color: #065f46; /* green-900 */
}
.message-error {
    background-color: #fee2e2; /* red-100 */
    border-left: 4px solid #dc2626; /* red-600 */
    color: #7f1d1d; /* red-900 */
}
.message-info {
    background-color: #e0f2fe; /* blue-100 */
    border-left: 4px solid #0284c7; /* light-blue-700 */
    color: #1e3a8a; /* blue-900 */
}

/* Loading Spinner Animation */
.loading-spinner {
    border: 4px solid rgba(0, 0, 0, 0.1);
    border-left-color: var(--primary-button-bg-light); /* Uses primary color for spin */
    border-radius: 50%;
    width: 24px;
    height: 24px;
    animation: spin 1s linear infinite;
    display: inline-block;
    vertical-align: middle;
    margin-left: 0.5rem;
}
@keyframes spin {
    to { transform: rotate(360deg); }
}

/* Badges for Auto-Mapped Fields */
.auto-mapped-badge {
    display: inline-block;
    font-size: 0.7rem;
    font-weight: 600;
    padding: 0.2rem 0.6rem;
    border-radius: 9999px;
    margin-left: 0.75rem;
    white-space: nowrap;
    transition: background-color 0.3s ease, color 0.3s ease;
}
.auto-mapped-badge.learned {
    background-color: var(--auto-mapped-learned-bg);
    color: var(--auto-mapped-learned-text);
}
.auto-mapped-badge.fuzzy {
    background-color: var(--auto-mapped-fuzzy-bg);
    color: var(--auto-mapped-fuzzy-text);
}
.auto-mapped-badge.unmapped {
    background-color: var(--auto-mapped-unmapped-bg);
    color: var(--auto-mapped-unmapped-text);
}

/* Tab Styling */
.tab-buttons {
    display: flex;
    gap: 0.5rem;
    margin-bottom: 1.5rem;
    padding: 0.375rem;
    background-color: var(--tab-button-bg);
    border-radius: 0.75rem;
    box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.05);
    transition: background-color 0.3s ease;
}
.tab-button {
    flex-grow: 1;
    padding: 0.625rem 1rem;
    border-radius: 0.625rem;
    text-align: center;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.3s ease-in-out;
    background-color: transparent;
    color: var(--tab-button-text);
    border: none;
}
.tab-button:hover {
    background-color: var(--tab-button-hover-bg);
}
.tab-button.active {
    background-color: var(--tab-button-active-bg);
    color: var(--tab-button-active-text);
    box-shadow: 0 2px 8px rgba(0,0,0,0.1), 0 1px 4px rgba(0,0,0,0.06);
    font-weight: 600;
}
.tab-button i {
    margin-right: 0.5rem;
}
.tab-content {
    transition: opacity 0.3s ease-in-out;
}
.tab-content.hidden {
    display: none;
}

/* Field Mapping Group Item */
.field-mapping-group-item {
    padding: 1rem; /* Slightly less padding than main card */
    margin-bottom: 1rem; /* Space between mapping groups */
}
.field-mapping-group-item .group-mapper {
    border: 1px solid var(--input-border-light);
    border-radius: 0.5rem;
    padding: 0.5rem 0.75rem;
    background-color: var(--card-bg-light);
    color: var(--text-color-light);
}

/* Specific styles for Auto Click section */
#clickableButtonsContainer {
    max-height: 15rem;
    overflow-y: auto;
    border: 1px solid var(--clickable-item-border);
    border-radius: 0.5rem;
    background-color: var(--clickable-container-bg);
    padding: 0.5rem;
    margin-bottom: 1.5rem;
    transition: background-color 0.3s ease, border-color 0.3s ease;
}
#clickableButtonsContainer > div {
    display: flex;
    align-items: center;
    padding: 0.625rem;
    border-bottom: 1px solid var(--clickable-item-border);
    border-radius: 0.375rem;
    margin-bottom: 0.25rem;
    transition: background-color 0.2s ease, border-color 0.2s ease;
}
#clickableButtonsContainer > div:last-child {
    border-bottom: none;
    margin-bottom: 0;
}
#clickableButtonsContainer > div:hover {
    background-color: var(--clickable-item-hover-bg);
}
#clickableButtonsContainer label {
    margin-left: 0.5rem;
    font-size: 0.95rem;
    color: var(--text-color-light);
    flex-grow: 1;
}
#clickableButtonsContainer input[type="radio"] {
    margin-right: 0.5rem;
    flex-shrink: 0;
}
#clickControlSection label {
    display: block;
    font-size: 0.9rem;
    font-weight: 500;
    color: var(--text-color-light);
    margin-bottom: 0.75rem;
}
/* Highlight for selected clickable button */
.selected-button-highlight {
    background-color: var(--selected-button-highlight-bg);
    border-color: var(--selected-button-highlight-border);
    font-weight: 600;
}

/* Theme Toggle Switch */
.theme-switch {
  position: absolute;
  top: 1rem;
  right: 1rem;
  z-index: 10;
}
.theme-switch input {
  display: none; /* Hide default checkbox */
}
.slider {
  width: 44px;
  height: 24px;
  background: var(--border-color-light); /* Light mode slider background */
  border-radius: 24px;
  cursor: pointer;
  position: relative;
  transition: background 0.3s ease;
  display: block;
}
.slider::before {
  content: "";
  position: absolute;
  top: 2px;
  left: 2px;
  width: 20px;
  height: 20px;
  background: var(--text-color-light); /* Light mode knob color */
  border-radius: 50%;
  transition: transform 0.3s ease, background 0.3s ease;
}
/* When checked (dark mode active) */
input:checked + .slider {
    background: var(--primary-button-bg-light); /* Primary color for slider background in light mode */
}
input:checked + .slider::before {
  transform: translateX(20px);
  background: white; /* White knob when checked */
}

/* Dark Mode Overrides (apply when body has 'dark' class) */
body.dark {
    background-color: var(--bg-color-dark);
    color: var(--text-color-dark);
}
.main-container.dark {
    background-color: var(--card-bg-dark);
    border-color: var(--border-color-dark);
}
.section-heading.dark, .card-heading.dark {
    color: var(--header-text-color-dark);
    border-color: var(--border-color-dark);
}
.card.dark {
    background-color: var(--card-bg-dark);
    border-color: var(--border-color-dark);
}
.action-button.primary.dark {
    background-color: var(--primary-button-bg-dark);
    --focus-ring-color-rgb: var(--primary-button-shadow-dark);
}
.action-button.primary.dark:hover {
    background-color: var(--primary-button-hover-bg-dark);
}
.action-button.emerald.dark {
    background-color: var(--emerald-button-bg-dark);
    --focus-ring-color-rgb: var(--emerald-button-shadow-dark);
}
.action-button.emerald.dark:hover {
    background-color: var(--emerald-button-hover-bg-dark);
}
.action-button.secondary.dark {
    background-color: var(--secondary-button-bg-dark);
    color: var(--text-color-dark);
    --focus-ring-color-rgb: 74, 85, 104; /* gray-700 RGB */
}
.action-button.secondary.dark:hover {
    background-color: var(--secondary-button-hover-bg-dark);
}
.form-input.dark {
    border-color: var(--input-border-dark);
    background-color: var(--card-bg-dark);
    color: var(--text-color-dark);
}
.form-input.dark:focus {
    border-color: var(--input-focus-ring-dark);
    box-shadow: 0 0 0 3px rgba(var(--input-focus-ring-rgb-values-dark), 0.3);
}
.drop-area.dark {
    border-color: var(--drop-area-border-dark);
    background-color: var(--drop-area-bg-dark);
}
.drop-area.dark:hover {
    background-color: var(--drop-area-hover-bg-dark);
    border-color: var(--primary-button-bg-dark);
}
.drop-area.dark p {
    color: var(--drop-area-text-dark);
}
.drop-area.dark:hover p {
    color: var(--drop-area-hover-text-dark);
}
.browse-button.dark {
    background-color: var(--primary-button-bg-dark);
}
.browse-button.dark:hover {
    background-color: var(--primary-button-hover-bg-dark);
}
.file-status.message-success.dark {
  background-color: var(--file-status-success-bg-dark);
  border-color: var(--file-status-success-border-dark);
  color: var(--file-status-success-text-dark);
}
.file-status.message-success.dark #fileStatusIcon {
    color: var(--file-status-success-icon-dark);
}
.file-status.message-error.dark {
  background-color: var(--file-status-error-bg-dark);
  border-color: var(--file-status-error-border-dark);
  color: var(--file-status-error-text-dark);
}
.file-status.message-error.dark #fileStatusIcon {
    color: var(--file-status-error-icon-dark);
}
.file-status.message-info.dark {
  background-color: var(--file-status-info-bg-dark);
  border-color: var(--file-status-info-border-dark);
  color: var(--file-status-info-text-dark);
}
.file-status.message-info.dark #fileStatusIcon {
    color: var(--file-status-info-icon-dark);
}
.headers-list.dark span {
    background-color: var(--header-badge-bg-dark);
    color: var(--header-badge-text-dark);
}
.headers-list.dark span:hover {
    background-color: var(--header-badge-hover-bg-dark);
}
.checkbox-label.dark, .radio-label.dark {
    color: var(--text-color-dark);
}
.checkbox-label.dark input[type="checkbox"], .radio-label.dark input[type="radio"] {
    border-color: var(--input-border-dark);
    background-color: var(--card-bg-dark);
}
.checkbox-label.dark input[type="checkbox"]:checked, .radio-label.dark input[type="radio"]:checked {
    background-color: var(--primary-button-bg-dark);
    border-color: var(--primary-button-bg-dark);
}
.checkbox-label.dark input[type="checkbox"]:focus, .radio-label.dark input[type="radio"]:focus {
    box-shadow: 0 0 0 3px rgba(var(--input-focus-ring-rgb-values-dark), 0.3);
}
/* Dark mode for generic message boxes */
.message-success.dark {
  background-color: #065f46; /* green-900 */
  border-left-color: #10b981; /* green-600 */
  color: #d1fae5; /* green-100 */
}
.message-error.dark {
  background-color: #7f1d1d; /* red-900 */
  border-left-color: #dc2626; /* red-600 */
  color: #fee2e2; /* red-100 */
}
.message-info.dark {
  background-color: #1e3a8a; /* blue-900 */
  border-left-color: #0284c7; /* light-blue-700 */
  color: #e0f2fe; /* blue-100 */
}
.auto-mapped-badge.learned.dark {
  background-color: var(--auto-mapped-learned-bg);
  color: var(--auto-mapped-learned-text);
}
.auto-mapped-badge.fuzzy.dark {
  background-color: var(--auto-mapped-fuzzy-bg);
  color: var(--auto-mapped-fuzzy-text);
}
.auto-mapped-badge.unmapped.dark {
  background-color: var(--auto-mapped-unmapped-bg);
  color: var(--auto-mapped-unmapped-text);
}
.tab-buttons.dark {
    background-color: var(--tab-button-bg-dark);
}
.tab-button.dark {
    color: var(--tab-button-text-dark);
}
.tab-button.dark:hover {
    background-color: var(--tab-button-hover-bg-dark);
}
.tab-button.active.dark {
    background-color: var(--tab-button-active-bg-dark);
    color: var(--tab-button-active-text-dark);
}
#clickableButtonsContainer.dark {
    border-color: var(--clickable-item-border);
    background-color: var(--clickable-container-bg);
}
#clickableButtonsContainer.dark > div {
    border-color: var(--clickable-item-border);
}
#clickableButtonsContainer.dark > div:hover {
    background-color: var(--clickable-item-hover-bg);
}
#clickableButtonsContainer.dark label {
    color: var(--text-color-dark);
}
#clickControlSection.dark {
    border-color: var(--clickable-item-border);
    background-color: var(--clickable-container-bg);
}
#clickControlSection.dark label {
    color: var(--text-color-dark);
}
.selected-button-highlight.dark {
    background-color: var(--selected-button-highlight-bg);
    border-color: var(--selected-button-highlight-border);
}
/* Dark mode for theme switch slider */
.theme-switch input:checked + .slider.dark {
    background: var(--primary-button-bg-dark);
}
.theme-switch input:checked + .slider.dark::before {
  background: white;
}
.slider.dark {
    background: var(--border-color-dark);
}
.slider.dark::before {
  background: var(--text-color-dark);
}


/* Responsive adjustments for smaller screens */
@media (max-width: 480px) {
  .main-container {
    padding: 1rem;
  }
  .section-heading, .card-heading {
    font-size: 1rem;
    margin-bottom: 0.75rem;
  }
  .action-button {
    padding: 0.6rem 1.2rem;
    font-size: 0.9rem;
  }
  .browse-button {
    padding: 0.75rem 1.5rem;
    font-size: 1rem;
  }
  .drop-area {
    padding: 1.5rem;
    min-height: 8rem;
  }
  .drop-area p {
    font-size: 1rem;
  }
  .file-status {
    font-size: 0.85rem;
    padding: 0.75rem 1rem;
  }
  .headers-list span {
    padding: 0.4rem 0.8rem;
    font-size: 0.8rem;
  }
  .tab-button {
    padding: 0.5rem 0.75rem;
    font-size: 0.9rem;
  }
  .theme-switch {
    top: 0.75rem;
    right: 0.75rem;
  }
}


--- END FILE: popup.css ---

--- START FILE: popup.html ---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spreadsheet Data Filler</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Inter font -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <!-- Fuse.js CDN for fuzzy matching -->
    <script src="https://cdn.jsdelivr.net/npm/fuse.js/dist/fuse.min.js"></script>
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <!-- Custom Stylesheet -->
    <link rel="stylesheet" href="popup.css">
</head>
<body class="bg-gray-50 dark:bg-gray-900 flex flex-col items-center justify-center min-h-screen p-4 transition-colors duration-300 antialiased">
    <!-- Main Container with responsive sizing and shadows -->
    <div class="main-container bg-white dark:bg-gray-800 rounded-xl shadow-2xl p-6 md:p-8 max-w-lg w-full border border-gray-200 dark:border-gray-700 relative transition-colors duration-300">
        <h1 class="text-2xl md:text-3xl font-bold text-gray-800 dark:text-gray-100 text-center mb-6 pb-2 border-b border-gray-200 dark:border-gray-700">Extension Features</h1>

        <!-- Dark Mode Toggle Switch -->
        <label class="theme-switch absolute top-4 right-4 md:top-6 md:right-6">
          <input type="checkbox" id="themeToggle">
          <span class="slider"></span>
        </label>

        <!-- Tab Buttons for switching features -->
        <div class="tab-buttons">
            <button id="autoFillTab" class="tab-button active">
                <i class="fas fa-file-excel mr-2"></i>Auto Fill
            </button>
            <button id="autoClickTab" class="tab-button">
                <i class="fas fa-mouse-pointer mr-2"></i>Auto Click
            </button>
        </div>

        <!-- Auto Fill Section: For uploading spreadsheets and filling forms -->
        <section id="autoFillSection" class="tab-content">
            <h2 class="section-heading text-xl md:text-2xl font-bold text-gray-800 dark:text-gray-100 mb-4 pb-2 border-b border-gray-200 dark:border-gray-700"><i class="fas fa-magic mr-2 text-blue-500"></i>Auto Fill Data</h2>
            
            <!-- Step 1: Upload File Card -->
            <div class="card mb-6">
                <h3 class="card-heading text-md md:text-lg font-semibold text-gray-700 dark:text-gray-200 mb-3"><i class="fas fa-upload mr-2 text-blue-500"></i>1. Upload File</h3>
                <p class="text-gray-600 dark:text-gray-400 text-sm mb-4">Supported: <span class="font-medium text-gray-700 dark:text-gray-300">.XLS, .XLSX, .ODS, .CSV, .XLSM, .XLSB.</span></p>
                
                <div class="drop-area" id="drop-area">
                    <!-- Hidden file input, triggered by the custom browse button -->
                    <input type="file" id="fileInput" class="hidden" accept=".xls,.xlsx,.ods,.csv,.xlsm,.xlsb" />
                    <p id="fileNameDisplay" class="text-gray-500 dark:text-gray-400 mb-4 group-hover:text-blue-700 dark:group-hover:text-blue-300 transition duration-300 ease-in-out">
                        Drag & Drop your file here, or
                    </p>
                    <label for="fileInput" class="browse-button">
                        Browse File
                    </label>
                </div>
                
                <!-- File status message area -->
                <div id="fileStatusMessage" class="file-status mt-4 hidden">
                    <i id="fileStatusIcon" class="text-xl mr-3"></i>
                    <span id="fileMessage" class="text-lg font-medium"></span>
                </div>
            </div>

            <!-- Step 2: Data Display & Field Mapping Card -->
            <div id="dataDisplaySection" class="card hidden">
                <h3 class="card-heading text-md md:text-lg font-semibold text-gray-700 dark:text-gray-200 mb-3"><i class="fas fa-map-marker-alt mr-2 text-blue-500"></i>2. Map Fields</h3>

                <div class="mb-4">
                    <h4 class="text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">File Headers:</h4>
                    <div id="headersDisplay" class="headers-list">
                        <!-- Spreadsheet headers will be displayed here dynamically -->
                    </div>
                </div>

                <!-- Scan fields button -->
                <button id="scanFieldsButton" class="action-button emerald w-full mb-4">
                    <i class="fas fa-sync-alt mr-2"></i>Scan Current Tab for Fields
                </button>
                <!-- Message area for scan feedback -->
                <div id="scanMessage" class="message-box mt-3 hidden"></div>

                <!-- Field Mapping Section (visible after scan) -->
                <div id="fieldMappingSection" class="mt-4 hidden">
                    <h4 class="text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Available Form Field Groups:</h4>
                    <div id="mappingContainer">
                        <!-- Dynamic mapping dropdowns for each grouped field -->
                    </div>
                    <div class="flex items-center mt-4">
                        <label class="checkbox-label mr-3 text-sm">
                            <input type="checkbox" id="fillEmptyOnlyCheckbox" class="mr-2">
                            Fill only empty fields
                        </label>
                    </div>

                    <!-- Action buttons for testing and previewing -->
                    <div class="flex flex-col space-y-2 mt-4">
                        <button id="testFillButton" class="action-button secondary w-full">
                            <i class="fas fa-vial mr-2"></i>Test Fill First Row
                        </button>
                        <div id="testFillMessage" class="message-box mt-3 hidden"></div>
                        <button id="previewValuesButton" class="action-button secondary w-full">
                            <i class="fas fa-eye mr-2"></i>Preview Mapped Values
                        </button>
                        <div id="previewValuesMessage" class="message-box mt-3 hidden"></div>
                    </div>
                </div>

                <!-- Main fill data button -->
                <button id="fillDataButton" class="action-button primary w-full mt-6">
                    <i class="fas fa-paper-plane mr-2"></i>Fill Data
                </button>
                <!-- One-Click Autofill button (hidden by default) -->
                <button id="oneClickAutofillButton" class="action-button primary w-full mt-2 hidden text-sm py-1.5 px-2">
                    <i class="fas fa-magic mr-1 text-sm"></i>One-Click Autofill (Auto-Map &amp; Fill)
                </button>
                <!-- Message area for fill data feedback -->
                <div id="fillDataMessage" class="message-box mt-3 hidden"></div>
            </div>
        </section>

        <!-- Auto Click Section: For automating button clicks -->
        <section id="autoClickSection" class="tab-content hidden">
            <h2 class="section-heading text-xl md:text-2xl font-bold text-gray-800 dark:text-gray-100 mb-4 pb-2 border-b border-gray-200 dark:border-gray-700"><i class="fas fa-mouse-pointer mr-2 text-indigo-500"></i>Auto Click Buttons</h2>
            <!-- Message area for auto click feedback -->
            <div id="autoClickMessage" class="message-box mb-4 hidden"></div>
            
            <!-- Step 1: Scan for Clickable Elements Card -->
            <div class="card mb-6">
                <h3 class="card-heading text-md md:text-lg font-semibold text-gray-700 dark:text-gray-200 mb-3"><i class="fas fa-search mr-2 text-indigo-500"></i>1. Scan for Clickable Elements</h3>
                <p class="text-gray-600 dark:text-gray-400 text-sm mb-3">Find buttons and other clickable elements on the current page.</p>
                <button id="scanButtons" class="action-button secondary w-full">
                    <i class="fas fa-sync-alt mr-2"></i>Scan for Clickable Buttons
                </button>
            </div>
            
            <!-- Step 2: Select a Button Card (visible after scan) -->
            <div id="selectButtonCard" class="card hidden mb-6">
                <h3 class="card-heading text-md md:text-lg font-semibold text-gray-700 dark:text-gray-200 mb-3"><i class="fas fa-hand-pointer mr-2 text-indigo-500"></i>2. Select a Button</h3>
                <div id="clickableButtonsContainer" class="max-h-60 overflow-y-auto border border-gray-200 dark:border-gray-600 rounded-lg bg-gray-50 dark:bg-gray-700 p-2 mb-4">
                    <!-- Clickable buttons will be listed here dynamically as radio buttons -->
                    <p class="text-gray-500 dark:text-gray-400 text-sm p-2">No buttons found yet. Click 'Scan' above.</p>
                </div>
            </div>

            <!-- Step 3: Choose Number of Clicks & Execute Card (visible after scan) -->
            <div id="clickControlSection" class="card hidden">
                <h3 class="card-heading text-md md:text-lg font-semibold text-gray-700 dark:text-gray-200 mb-3"><i class="fas fa-play-circle mr-2 text-indigo-500"></i>3. Choose Number of Clicks & Execute</h3>
                <label for="clickCount" class="text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 block">Number of clicks:</label>
                <input type="number" id="clickCount" value="1" min="1" class="mb-4 form-input" />
                <button id="startClicking" class="action-button primary w-full">
                    <i class="fas fa-bullseye mr-2"></i>Start Clicking
                </button>
            </div>
        </section>
    </div>

    <!-- SheetJS Library - NOW LOCAL -->
    <script src="xlsx.full.min.js"></script>
    <script src="popup.js"></script>
    <script>
        // Global error handler for better debugging in the popup context
        window.onerror = function (msg, url, lineNo, columnNo, error) {
            console.error('Global Error (popup.html):', { msg, url, lineNo, columnNo, error });
            const errorMessageElement = document.getElementById('fileStatusMessage') || document.getElementById('scanMessage') || document.getElementById('fillDataMessage') || document.getElementById('autoClickMessage');
            if (errorMessageElement) {
                // Display a user-friendly error message, avoiding specific internal details
                errorMessageElement.innerHTML = `<i class="fas fa-exclamation-circle text-red-500 text-xl mr-3"></i><span class="text-lg font-medium">An unexpected error occurred. Please try again. If the issue persists, check the browser's console for more details.</span>`;
                errorMessageElement.className = 'file-status message-error';
                errorMessageElement.classList.remove('hidden');
                
                // Set a timeout to hide the error message after a few seconds
                setTimeout(() => {
                    errorMessageElement.classList.add('hidden');
                    errorMessageElement.innerHTML = '';
                }, 7000); // Increased visibility duration for critical errors
            }
        };
    </script>
</body>
</html>


--- END FILE: popup.html ---

--- START FILE: popup.js ---

// Global variables to store parsed data and headers
let workbook = null;
let sheetData = []; // Stores all data from the first sheet (including headers as first row)
let headers = [];   // Stores the first row (headers)
let availableFormFields = []; // Stores fields found on the active tab
let groupedFormFields = {}; // Stores fields grouped by their 'surroundingText' or derived name
let learnedMappings = {}; // Stores user's preferred mappings for schema learning

// DOM Elements - Tabs
const autoFillTab = document.getElementById("autoFillTab");
const autoClickTab = document.getElementById("autoClickTab");
const autoFillSection = document.getElementById("autoFillSection");
const autoClickSection = document.getElementById("autoClickSection");

// DOM Elements - Auto Fill Section
const fileInput = document.getElementById('fileInput');
const dropArea = document.getElementById('drop-area'); // Reference to the drag and drop area
const fileNameDisplay = document.getElementById('fileNameDisplay'); // Used for "Drag & Drop..." text initially, then file name
const fileStatusMessage = document.getElementById('fileStatusMessage'); // The combined status div
const fileMessage = document.getElementById('fileMessage'); // Span inside status div for text
const fileStatusIcon = document.getElementById('fileStatusIcon'); // Icon inside status div
const dataDisplaySection = document.getElementById('dataDisplaySection');
const headersDisplay = document.getElementById('headersDisplay');
const scanFieldsButton = document.getElementById('scanFieldsButton');
const scanMessage = document.getElementById('scanMessage');
const fieldMappingSection = document.getElementById('fieldMappingSection');
const mappingContainer = document.getElementById('mappingContainer');
const fillDataButton = document.getElementById('fillDataButton');
const fillDataMessage = document.getElementById('fillDataMessage');
const fillEmptyOnlyCheckbox = document.getElementById('fillEmptyOnlyCheckbox');
const oneClickAutofillButton = document.getElementById('oneClickAutofillButton');
const testFillButton = document.getElementById('testFillButton');
const previewValuesButton = document.getElementById('previewValuesButton');
const testFillMessage = document.getElementById('testFillMessage');
const previewValuesMessage = document.getElementById('previewValuesMessage');

// DOM Elements - Auto Click Section
const scanButtons = document.getElementById("scanButtons");
const clickableButtonsContainer = document.getElementById("clickableButtonsContainer");
const clickCountInput = document.getElementById("clickCount");
const startClickingButton = document.getElementById("startClicking");
const autoClickMessage = document.getElementById("autoClickMessage");
const selectButtonCard = document.getElementById("selectButtonCard"); // Card for step 2
const clickControlSection = document.getElementById("clickControlSection"); // Card for step 3

// DOM Elements - Theme Toggle
const themeToggle = document.getElementById('themeToggle');


// --- Event Listeners ---

// Tab switching logic
autoFillTab.addEventListener("click", () => switchTab('autoFill'));
autoClickTab.addEventListener("click", () => switchTab('autoClick'));

// Theme toggle logic
themeToggle.addEventListener('change', () => {
    // Toggle 'dark' class on the body to apply dark mode styles
    const isDarkMode = themeToggle.checked;
    document.body.classList.toggle('dark', isDarkMode);

    // Get all elements that need their 'dark' class toggled based on the theme state
    const elementsToToggle = [
        document.querySelector('.main-container'),
        ...document.querySelectorAll('.card'),
        ...document.querySelectorAll('.section-heading'),
        ...document.querySelectorAll('.card-heading'),
        ...document.querySelectorAll('.action-button'),
        ...document.querySelectorAll('.form-input'),
        ...document.querySelectorAll('.drop-area'),
        ...document.querySelectorAll('.browse-button'),
        ...document.querySelectorAll('.file-status'),
        ...document.querySelectorAll('.headers-list'),
        ...document.querySelectorAll('.headers-list span'),
        ...document.querySelectorAll('.checkbox-label'),
        ...document.querySelectorAll('.radio-label'),
        ...document.querySelectorAll('.message-box'),
        ...document.querySelectorAll('.auto-mapped-badge'),
        ...document.querySelectorAll('.tab-buttons'),
        ...document.querySelectorAll('.tab-button'),
        document.getElementById('clickableButtonsContainer'),
        ...document.querySelectorAll('#clickableButtonsContainer > div'),
        ...document.querySelectorAll('#clickableButtonsContainer label'),
        document.getElementById('clickControlSection'),
        ...document.querySelectorAll('#clickControlSection label'),
        ...document.querySelectorAll('.selected-button-highlight'),
        ...document.querySelectorAll('.slider')
    ].filter(Boolean); // Filter out nulls if elements aren't always present

    elementsToToggle.forEach(el => {
        el.classList.toggle('dark', isDarkMode);
        // Special handling for selected-button-highlight on tab switch
        if (el.classList.contains('selected-button-highlight')) {
            el.classList.toggle('dark:selected-button-highlight', isDarkMode);
        }
        // Special handling for tab buttons active state
        if (el.classList.contains('tab-button') && el.classList.contains('active')) {
            el.classList.toggle('dark:active', isDarkMode);
        }
    });

    // Store user's theme preference in local storage
    localStorage.setItem('theme', isDarkMode ? 'dark' : 'light');
});

// File input change
fileInput.addEventListener('change', handleFile);

// Drag and drop functionality for file input
dropArea.addEventListener('dragover', (e) => {
    e.preventDefault();
    dropArea.classList.add('border-blue-600', 'bg-blue-100', 'dark:border-indigo-500', 'dark:bg-indigo-900');
    // Add hover text color effects only when dragging over
    fileNameDisplay.classList.add('group-hover:text-blue-700', 'dark:group-hover:text-blue-300'); 
});
dropArea.addEventListener('dragleave', (e) => {
    e.preventDefault();
    dropArea.classList.remove('border-blue-600', 'bg-blue-100', 'dark:border-indigo-500', 'dark:bg-indigo-900');
    fileNameDisplay.classList.remove('group-hover:text-blue-700', 'dark:group-hover:text-blue-300');
});
dropArea.addEventListener('drop', (e) => {
    e.preventDefault();
    dropArea.classList.remove('border-blue-600', 'bg-blue-100', 'dark:border-indigo-500', 'dark:bg-indigo-900');
    fileNameDisplay.classList.remove('group-hover:text-blue-700', 'dark:group-hover:text-blue-300');
    if (e.dataTransfer.files.length > 0) {
        fileInput.files = e.dataTransfer.files;
        handleFile();
    }
});

// Scan fields button click
scanFieldsButton.addEventListener('click', async () => {
    await scanCurrentTabFields();
});

// Fill data button click
fillDataButton.addEventListener('click', () => fillDataInTab(false));

// One-Click Autofill button click
oneClickAutofillButton.addEventListener('click', () => fillDataInTab(true));

// Test Fill button click
testFillButton.addEventListener('click', () => testFillFirstRow());

// Preview Values button click
previewValuesButton.addEventListener('click', () => previewMappedValues());

// Helper to check if content script is already loaded and responsive
async function isContentScriptLoaded(tabId) {
    try {
        // Send a dummy message to content.js and expect a 'pong' response
        const response = await chrome.tabs.sendMessage(tabId, { action: "ping" });
        return response && response.status === "pong";
    } catch (e) {
        // If an error occurs (e.g., recipient disconnected, script not injected),
        // it means the content script is not loaded or not responding.
        return false;
    }
}


// Auto Click Event Listeners
scanButtons.addEventListener("click", async () => {
    displayFileStatusMessage('<i class="fas fa-spinner fa-spin"></i>Scanning for clickable buttons...', 'info', autoClickMessage, true);
    scanButtons.disabled = true;
    scanButtons.innerHTML = 'Scanning... <span class="loading-spinner"></span>';
    clickableButtonsContainer.innerHTML = '<p class="text-gray-500 dark:text-gray-400 text-sm p-2">Scanning...</p>'; // Clear previous buttons and show scanning message

    try {
        const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });
        if (!tab) {
            displayFileStatusMessage('Could not get active tab.', 'error', autoClickMessage, true);
            return;
        }

        // Ensure content.js is injected only once per tab
        const loaded = await isContentScriptLoaded(tab.id);
        if (!loaded) {
            await chrome.scripting.executeScript({
                target: { tabId: tab.id },
                files: ['content.js']
            });
        }

        // Now that content.js is guaranteed to be loaded, send the actual scan message
        const response = await chrome.tabs.sendMessage(tab.id, { action: "scanClickables" });

        if (response && response.clickables) {
            if (response.clickables.length > 0) {
                clickableButtonsContainer.innerHTML = ''; // Clear scanning message
                response.clickables.forEach((btn, index) => {
                    const btnDiv = document.createElement("div");
                    btnDiv.className = "flex items-center mb-1 last:mb-0 border-b border-gray-200 dark:border-gray-600 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-md transition-colors duration-200 p-2";
                    btnDiv.innerHTML = `
                        <input type="radio" name="clickable" value="${btn.stableId}" id="btn-${index}" class="mr-2 flex-shrink-0">
                        <label for="btn-${index}" class="text-sm text-gray-700 dark:text-gray-300 flex-grow">${btn.text}</label>
                    `;
                    clickableButtonsContainer.appendChild(btnDiv);

                    // Add event listener to highlight selected radio button
                    btnDiv.querySelector('input[type="radio"]').addEventListener('change', (e) => {
                        // Remove highlight from all other buttons
                        document.querySelectorAll('#clickableButtonsContainer > div').forEach(div => {
                            div.classList.remove('selected-button-highlight');
                            // Ensure dark mode highlight is also removed/added correctly
                            div.classList.remove('dark:selected-button-highlight'); 
                        });
                        // Add highlight to the newly selected button's parent div
                        if (e.target.checked) {
                            btnDiv.classList.add('selected-button-highlight');
                            if (document.body.classList.contains('dark')) {
                                btnDiv.classList.add('dark:selected-button-highlight');
                            }
                        }
                    });
                });
                selectButtonCard.classList.remove("hidden"); // Show Step 2 card
                clickControlSection.classList.remove("hidden"); // Show Step 3 card
                displayFileStatusMessage(`<i class="fas fa-check-circle"></i>Found ${response.clickables.length} clickable elements.`, 'success', autoClickMessage, true);
            } else {
                clickableButtonsContainer.innerHTML = "<p class='text-gray-500 dark:text-gray-400 text-sm p-2'>No clickable buttons found on this page.</p>";
                selectButtonCard.classList.add("hidden");
                clickControlSection.classList.add("hidden");
                displayFileStatusMessage('<i class="fas fa-info-circle"></i>No clickable buttons found on the current tab.', 'info', autoClickMessage, true);
            }
        } else {
            clickableButtonsContainer.innerHTML = "<p class='text-gray-500 dark:text-gray-400 text-sm p-2'>Failed to scan for buttons.</p>";
            selectButtonCard.classList.add("hidden");
            clickControlSection.classList.add("hidden");
            displayFileStatusMessage('<i class="fas fa-exclamation-triangle"></i>Failed to get clickable elements from the current tab. Ensure content script can run.', 'error', autoClickMessage, true);
        }
    } catch (error) {
        console.error("Error scanning buttons:", error);
        displayFileStatusMessage(`<i class="fas fa-exclamation-triangle"></i>Error scanning buttons: ${error.message}. Check console for details.`, 'error', autoClickMessage, true);
        clickableButtonsContainer.innerHTML = "<p class='text-gray-500 dark:text-gray-400 text-sm p-2'>Error scanning for buttons. Check console for details.</p>";
        selectButtonCard.classList.add("hidden");
        clickControlSection.classList.add("hidden");
    } finally {
        scanButtons.disabled = false;
        scanButtons.innerHTML = '<i class="fas fa-sync-alt mr-2"></i>Scan for Clickable Buttons';
    }
});

startClickingButton.addEventListener("click", async () => {
    const count = parseInt(clickCountInput.value);
    const selected = document.querySelector('input[name="clickable"]:checked');
    const stableId = selected?.value;

    if (isNaN(count) || count < 1) {
        displayFileStatusMessage("Please enter a valid number of clicks (1 or more).", "error", autoClickMessage, false);
        return;
    }

    if (!stableId) {
        displayFileStatusMessage("Please select a button to click.", "error", autoClickMessage, false);
        return;
    }

    displayFileStatusMessage(`<i class="fas fa-circle-notch fa-spin"></i>Attempting to click ${count} time(s)...`, 'info', autoClickMessage, true);
    startClickingButton.disabled = true;
    startClickingButton.innerHTML = 'Clicking... <span class="loading-spinner"></span>';


    try {
        const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });
        if (!tab) {
            displayFileStatusMessage('Could not get active tab.', 'error', autoClickMessage, false);
            return;
        }

        // Send message to content script to perform the clicks
        const response = await chrome.tabs.sendMessage(tab.id, {
            action: "performClick",
            stableId,
            count
        });

        if (response?.status === "success") {
            displayFileStatusMessage(`<i class="fas fa-check-circle"></i>Clicked ${count} time(s) successfully.`, "success", autoClickMessage, true);
        } else {
            console.error(`Error during click: ${response?.message || 'Unknown error.'}`);
            displayFileStatusMessage(`<i class="fas fa-exclamation-triangle"></i>Failed to click: ${response?.message || 'Unknown error.'}`, "error", autoClickMessage, true);
        }
    } catch (error) {
        console.error("Error performing click:", error);
        displayFileStatusMessage(`<i class="fas fa-exclamation-triangle"></i>Error performing click: ${error.message}.`, "error", autoClickMessage, true);
    } finally {
        startClickingButton.disabled = false;
        startClickingButton.innerHTML = '<i class="fas fa-bullseye mr-2"></i>Start Clicking';
    }
});

// Load learned mappings and initial tab on startup
document.addEventListener('DOMContentLoaded', () => {
    loadLearnedMappings();
    loadTabPreference();
    // Load theme preference on DOMContentLoaded and apply it immediately
    const theme = localStorage.getItem('theme');
    if (theme === 'dark') {
      themeToggle.checked = true; // Set the toggle to checked state
    }
    // Manually trigger the change event to apply the theme classes on initial load
    // This ensures all dynamically added elements (like file status, mapping groups) also get the correct theme
    themeToggle.dispatchEvent(new Event('change'));
});


// --- Functions ---

/**
 * Switches between the Auto Fill and Auto Click tabs.
 * @param {string} activeTabId - The ID of the tab to activate ('autoFill' or 'autoClick').
 */
async function switchTab(activeTabId) {
    // Remove active class from all tabs and add to the selected one
    autoFillTab.classList.remove('active', 'dark:active');
    autoClickTab.classList.remove('active', 'dark:active');
    
    const targetTabButton = document.getElementById(`${activeTabId}Tab`);
    targetTabButton.classList.add('active');
    // Ensure dark mode active class is applied if current theme is dark
    if (document.body.classList.contains('dark')) {
        targetTabButton.classList.add('dark:active');
    }

    // Hide all tab sections and show the selected one
    autoFillSection.classList.add('hidden');
    autoClickSection.classList.add('hidden');
    document.getElementById(`${activeTabId}Section`).classList.remove('hidden');

    // Save tab preference to chrome.storage.sync
    try {
        await chrome.storage.sync.set({ activeTab: activeTabId });
    } catch (error) {
        console.error('Error saving tab preference:', error);
    }
}

/**
 * Loads the last active tab preference from chrome.storage.sync.
 */
async function loadTabPreference() {
    try {
        const result = await chrome.storage.sync.get('activeTab');
        const lastActiveTab = result.activeTab || 'autoFill'; // Default to autoFill
        switchTab(lastActiveTab);
    } catch (error) {
        console.error('Error loading tab preference:', error);
        switchTab('autoFill'); // Fallback to default in case of error
    }
}


/**
 * Handles the file selection and reads its content.
 */
function handleFile() {
    const file = fileInput.files[0];
    if (!file) {
        displayFileStatusMessage('<i class="fas fa-exclamation-triangle"></i>No file selected.', 'error', fileStatusMessage, true);
        return;
    }

    fileNameDisplay.textContent = `File: "${file.name}"`; // Update text to show file name
    displayFileStatusMessage(`<i class="fas fa-spinner fa-spin"></i>Reading "${file.name}"...`, 'info', fileStatusMessage, true);

    const reader = new FileReader();

    reader.onload = function(e) {
        try {
            const data = new Uint8Array(e.target.result);
            // Read the workbook using SheetJS
            workbook = XLSX.read(data, { type: 'array' });

            // Get the first sheet name
            const sheetName = workbook.SheetNames[0];
            // Convert the first sheet to JSON, ensuring header:1 to get raw array of arrays
            sheetData = XLSX.utils.sheet_to_json(workbook.Sheets[sheetName], { header: 1 });

            if (sheetData.length === 0) {
                displayFileStatusMessage('<i class="fas fa-exclamation-triangle"></i>The selected file is empty or could not be parsed.', 'error', fileStatusMessage, true);
                dataDisplaySection.classList.add('hidden');
                oneClickAutofillButton.classList.add('hidden'); // Hide autofill if no data
                return;
            }

            // The first row is the headers
            headers = sheetData[0];
            
            displayHeaders(headers); // Update UI with headers
            dataDisplaySection.classList.remove('hidden');
            displayFileStatusMessage(`<i class="fas fa-check-circle"></i>File "${file.name}" loaded successfully.`, 'success', fileStatusMessage, true);

            // If fields were already scanned, re-setup mapping with new headers and re-auto-map
            if (Object.keys(groupedFormFields).length > 0) { // Check groupedFormFields for existing scan
                setupFieldMapping(groupedFormFields, headers); // Re-setup mapping with new headers
                autoMapFields(groupedFormFields, headers); // Re-run auto-map
                fieldMappingSection.classList.remove('hidden');
                oneClickAutofillButton.classList.remove('hidden'); // Show autofill if fields and headers exist
            } else {
                // If no fields scanned yet, hide autofill button
                oneClickAutofillButton.classList.add('hidden');
            }

        } catch (error) {
            console.error("Error reading file:", error);
            displayFileStatusMessage(`<i class="fas fa-exclamation-triangle"></i>Error reading file: ${error.message}. Please ensure it's a valid spreadsheet format.`, 'error', fileStatusMessage, true);
            dataDisplaySection.classList.add('hidden');
            oneClickAutofillButton.classList.add('hidden');
        }
    };

    reader.onerror = function(e) {
        console.error("FileReader error:", e);
        displayFileStatusMessage(`<i class="fas fa-exclamation-triangle"></i>Error reading file: ${e.target.error.name}.`, 'error', fileStatusMessage, true);
        dataDisplaySection.classList.add('hidden');
        oneClickAutofillButton.classList.add('hidden');
    };

    reader.readAsArrayBuffer(file);
}

/**
 * Displays the extracted headers in the UI.
 * @param {string[]} headersArray - Array of header strings.
 */
function displayHeaders(headersArray) {
    headersDisplay.innerHTML = ''; // Clear previous headers
    if (headersArray.length > 0) {
        headersArray.forEach(header => {
            const span = document.createElement('span');
            // Apply theme classes based on current body theme
            span.className = `px-5 py-2 rounded-full text-base font-medium shadow-sm flex items-center transition-colors duration-200 cursor-default ${document.body.classList.contains('dark') ? 'bg-indigo-700 text-indigo-100 hover:bg-indigo-600' : 'bg-indigo-100 text-indigo-800 hover:bg-indigo-200'}`;
            span.textContent = header;
            headersDisplay.appendChild(span);
        });
    } else {
        headersDisplay.textContent = 'No headers found in the first row.';
        headersDisplay.classList.add('text-gray-500', 'dark:text-gray-400', 'text-sm');
    }
}

/**
 * Sends a message to the content script to scan for form fields.
 */
async function scanCurrentTabFields() {
    if (!headers || headers.length === 0) {
        displayMessage(scanMessage, '<i class="fas fa-exclamation-triangle mr-2"></i>Please upload a file with headers first.', 'error', true);
        return;
    }

    displayMessage(scanMessage, '<i class="fas fa-spinner fa-spin mr-2"></i>Scanning current tab for fields...', 'info', true);
    scanFieldsButton.disabled = true; // Disable button during scan
    scanFieldsButton.innerHTML = 'Scanning... <span class="loading-spinner"></span>';
    oneClickAutofillButton.classList.add('hidden'); // Hide autofill button during scan

    try {
        // Get the active tab
        const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });
        if (!tab) {
            displayMessage(scanMessage, 'Could not get active tab.', 'error', false);
            return;
        }

        // Ensure content.js is injected only once per tab
        const loaded = await isContentScriptLoaded(tab.id);
        if (!loaded) {
            await chrome.scripting.executeScript({
                target: { tabId: tab.id },
                files: ['content.js']
            });
        }

        // Now that content.js is guaranteed to be loaded, send the actual scan message
        const response = await chrome.tabs.sendMessage(tab.id, { action: 'scanFields' });

        if (response && response.fields) {
            availableFormFields = response.fields;
            if (availableFormFields.length > 0) {
                groupedFormFields = groupFieldsBySignature(availableFormFields); // Use smarter grouping
                setupFieldMapping(groupedFormFields, headers); // Call existing setup to build UI with grouped fields
                autoMapFields(groupedFormFields, headers); // Call auto-map to pre-select dropdowns for groups
                fieldMappingSection.classList.remove('hidden');
                displayMessage(scanMessage, `<i class="fas fa-check-circle mr-2"></i>Found ${availableFormFields.length} fields on the page, grouped into ${Object.keys(groupedFormFields).length} sections. Attempting auto-mapping.`, 'success', true);
                oneClickAutofillButton.classList.remove('hidden'); // Show autofill button if fields found
            } else {
                fieldMappingSection.classList.add('hidden');
                displayMessage(scanMessage, '<i class="fas fa-info-circle mr-2"></i>No input fields found on the current tab.', 'info', true);
                oneClickAutofillButton.classList.add('hidden'); // Hide autofill button if no fields
            }
        } else {
            fieldMappingSection.classList.add('hidden');
            displayMessage(scanMessage, '<i class="fas fa-exclamation-triangle mr-2"></i>Failed to get fields from the current tab. Ensure content script can run.', 'error', true);
            oneClickAutofillButton.classList.add('hidden'); // Hide autofill button if error
        }
    } catch (error) {
        console.error("Error scanning fields:", error);
        displayMessage(scanMessage, `<i class="fas fa-exclamation-triangle mr-2"></i>Error scanning fields: ${error.message}.`, 'error', true);
        fieldMappingSection.classList.add('hidden');
        oneClickAutofillButton.classList.add('hidden'); // Hide autofill button if error
    } finally {
        scanFieldsButton.disabled = false;
        scanFieldsButton.innerHTML = '<i class="fas fa-sync-alt mr-2"></i>Scan Current Tab for Fields';
    }
}

/**
 * Generates a comprehensive signature for a form field using multiple attributes.
 * This signature is used for smarter grouping and fuzzy matching.
 * @param {Object} field - The field object from content.js.
 * @returns {string} A combined string representing the field's unique signature.
 */
function generateFieldSignature(field) {
    const parts = [
        field.labelText,
        field.name,
        field.placeholder,
        field.ariaLabel,
        field.title,
        field.autocomplete,
        field.surroundingText
    ].filter(Boolean) // Filter out empty strings/nulls/undefineds
     .map(str => str.toLowerCase().replace(/[^a-z0-9\s]/g, '').trim()) // Clean and normalize strings
     .filter(str => str.length > 1); // Only include parts longer than 1 character

    // Use a Set to ensure unique parts and then join them
    return [...new Set(parts)].join(" | ");
}

/**
 * Groups form fields by their generated signature to create logical sections.
 * @param {Array<Object>} formFields - Array of field objects from content.js.
 * @returns {Object} An object where keys are grouping contexts (signatures) and values are arrays of fields.
 */
function groupFieldsBySignature(formFields) {
    const groups = {};
    formFields.forEach(field => {
        const signature = generateFieldSignature(field);
        // Fallback to htmlId if signature is empty, otherwise a generic label
        const groupIdentifier = signature || field.htmlId || `Unnamed Field Group (${field.type})`;
        
        if (!groups[groupIdentifier]) {
            groups[groupIdentifier] = [];
        }
        groups[groupIdentifier].push(field);
    });
    return groups;
}

/**
 * Sets up the mapping section with dropdowns for each grouped form field context.
 * @param {Object} groupedFields - Object of grouped fields (e.g., { 'Context A': [field1, field2], 'Context B': [field3] }).
 * @param {string[]} headersArray - Array of header strings for dropdown options.
 */
function setupFieldMapping(groupedFields, headersArray) {
    mappingContainer.innerHTML = ''; // Clear previous mappings

    const groupKeys = Object.keys(groupedFields);
    if (groupKeys.length === 0) {
        mappingContainer.textContent = 'No mappable field groups found on the page.';
        mappingContainer.classList.add('text-gray-500', 'dark:text-gray-400', 'text-sm');
        return;
    }
    // Remove informational text if there are groups to display
    mappingContainer.classList.remove('text-gray-500', 'dark:text-gray-400', 'text-sm');

    groupKeys.forEach(contextKey => {
        const fieldsInGroup = groupedFields[contextKey];
        const mappingGroupItem = document.createElement('div');
        // Apply card styling and theme class
        mappingGroupItem.className = `field-mapping-group-item card ${document.body.classList.contains('dark') ? 'dark' : ''}`;
        
        const groupHeader = document.createElement('h3');
        groupHeader.className = `text-md font-semibold text-gray-800 dark:text-gray-200 mb-3 flex items-center card-heading ${document.body.classList.contains('dark') ? 'dark' : ''}`;
        groupHeader.textContent = contextKey;
        mappingGroupItem.appendChild(groupHeader);

        const groupControl = document.createElement('div');
        groupControl.className = 'flex flex-col sm:flex-row items-start sm:items-center space-y-2 sm:space-y-0 sm:space-x-2 mb-3';

        const label = document.createElement('label');
        // Apply theme class to label
        label.className = `checkbox-label flex-shrink-0 ${document.body.classList.contains('dark') ? 'dark' : ''}`;
        
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.className = 'group-checkbox mr-2';
        checkbox.dataset.contextKey = contextKey;
        checkbox.checked = false; // Initially unchecked

        const span = document.createElement('span');
        span.className = 'text-sm text-gray-700 dark:text-gray-300';
        span.textContent = `Map fields for "${contextKey}"`;

        label.appendChild(checkbox);
        label.appendChild(span);
        groupControl.appendChild(label);

        const select = document.createElement('select');
        // Apply form-input and theme class to select
        select.className = `group-mapper flex-grow mt-2 sm:mt-0 form-input ${document.body.classList.contains('dark') ? 'dark' : ''}`;
        select.dataset.contextKey = contextKey;
        select.disabled = true; // Initially disabled

        const fragment = document.createDocumentFragment();
        const defaultOption = document.createElement('option');
        defaultOption.value = '';
        defaultOption.textContent = '-- Select Column --';
        fragment.appendChild(defaultOption);

        headersArray.forEach(header => {
            const option = document.createElement('option');
            option.value = header;
            option.textContent = header;
            fragment.appendChild(option);
        });
        select.appendChild(fragment);
        groupControl.appendChild(select);
        mappingGroupItem.appendChild(groupControl);

        // Display individual fields within this group (read-only for user information)
        const fieldListContainer = document.createElement('div');
        fieldListContainer.className = 'mt-2 text-xs text-gray-600 dark:text-gray-400';
        fieldListContainer.innerHTML = '<p class="font-medium mb-1">Instances of this field on page:</p>';
        fieldsInGroup.forEach(field => {
            // Generate a user-friendly display name for the field instance
            let displayName = field.labelText || field.name || field.placeholder || field.ariaLabel || field.title || 'Unnamed Field Instance';
            displayName = displayName.replace(/\[\d+\]/g, '').trim(); // Clean array-like indexing
            if (displayName.startsWith('stable-id-') || displayName.startsWith('generated-id-')) {
                displayName = 'Unnamed Field Instance'; // Generic label for programmatically generated IDs
            }

            const fieldSpan = document.createElement('span');
            // Apply theme classes for the field instance badges
            fieldSpan.className = `inline-block px-2 py-0.5 rounded-full mr-1 mb-1 ${document.body.classList.contains('dark') ? 'bg-gray-700 text-gray-300' : 'bg-gray-100 text-gray-700'}`;
            fieldSpan.textContent = displayName;
            fieldListContainer.appendChild(fieldSpan);
        });
        mappingGroupItem.appendChild(fieldListContainer);

        mappingContainer.appendChild(mappingGroupItem);

        // Event listener for group checkbox: enables/disables the select dropdown
        checkbox.addEventListener('change', (e) => {
            const currentSelect = mappingContainer.querySelector(`.group-mapper[data-context-key="${e.target.dataset.contextKey}"]`);
            currentSelect.disabled = !e.target.checked;
            if (!e.target.checked) {
                currentSelect.value = ''; // Reset selection if unchecked
                removeAutoMappedBadge(groupHeader); // Remove badge when unchecked
            } else {
                // If re-checked, try auto-mapping again for visual consistency (e.g., if user changed it manually and then re-enabled)
                autoMapFields(groupedFields, headersArray); 
            }
        });

        // Event listener for select change to save mapping and update badge
        select.addEventListener('change', () => {
            saveLearnedMappings(); // Save whenever a mapping is changed by the user
            // Update badge based on current selection, assuming it's a manual selection if changed here
            const selectedHeader = select.value;
            if (selectedHeader) {
                updateBadgeForGroup(groupHeader, 'learned', ''); // Indicate it's now a learned mapping
            } else {
                removeAutoMappedBadge(groupHeader); // Remove badge if selection is cleared
            }
        });
    });
}

/**
 * Performs intelligent auto-mapping between grouped form fields and spreadsheet headers using Fuse.js.
 * Populates the mapping dropdowns and checks the corresponding checkboxes for groups.
 * @param {Object} groupedFields - Object of grouped fields.
 * @param {string[]} headersArray - Array of header strings.
 */
async function autoMapFields(groupedFields, headersArray) {
    await loadLearnedMappings(); // Ensure learned mappings are loaded first

    // Guard against empty headers array for Fuse.js initialization
    if (!headersArray || headersArray.length === 0) {
        console.warn("Headers array is empty, cannot perform auto-mapping.");
        displayMessage(scanMessage, '<i class="fas fa-info-circle mr-2"></i>Cannot auto-map: No headers found in the uploaded file.', 'info', true);
        return;
    }

    const fuseOptions = {
        includeScore: true,
        threshold: 0.4, // Lower is stricter, 0.4 allows for some flexibility
        keys: ['header'] // Fuse will search within the 'header' property of our items
    };

    // Prepare headers for Fuse.js search
    const fuse = new Fuse(headersArray.map(h => ({ header: h })), fuseOptions);

    let autoMappedCount = 0;
    Object.keys(groupedFields).forEach(contextKey => {
        const checkbox = mappingContainer.querySelector(`.group-checkbox[data-context-key="${contextKey}"]`);
        const select = mappingContainer.querySelector(`.group-mapper[data-context-key="${contextKey}"]`);
        const groupHeaderElement = checkbox.closest('.field-mapping-group-item').querySelector('h3');

        if (!checkbox || !select) return; // Skip if elements not found

        let mappedType = 'unmapped'; // Default mapping type

        // 1. Prioritize applying a previously learned mapping
        if (learnedMappings[contextKey] && headersArray.includes(learnedMappings[contextKey])) {
            checkbox.checked = true;
            select.disabled = false;
            select.value = learnedMappings[contextKey];
            mappedType = 'learned';
            autoMappedCount++;
            console.log(`Auto-mapping (Learned): "${contextKey}" -> "${learnedMappings[contextKey]}"`);
        } else {
            // 2. Fallback to fuzzy matching if no learned mapping or learned mapping is no longer valid (e.g., header changed)
            const result = fuse.search(contextKey)[0]; // Get the best fuzzy match
            if (result && result.score < 0.4) { // Apply if confidence (score) is high enough
                const bestMatchHeader = result.item.header;
                checkbox.checked = true;
                select.disabled = false;
                select.value = bestMatchHeader;
                mappedType = 'fuzzy';
                autoMappedCount++;
                console.log(`Auto-mapping (Fuzzy): "${contextKey}" -> "${bestMatchHeader}" (Score: ${result.score.toFixed(2)})`);
            } else {
                // If no auto-mapping, ensure checkbox is unchecked and select is disabled and reset
                checkbox.checked = false;
                select.disabled = true;
                select.value = '';
                mappedType = 'unmapped';
                console.log(`No strong auto-mapping for "${contextKey}" (Best score: ${result?.score.toFixed(2) || 'N/A'})`);
            }
        }
        // Update the visual badge for the group based on the mapping type
        updateBadgeForGroup(groupHeaderElement, mappedType, mappedType === 'fuzzy' ? result.score.toFixed(2) : '');
    });
    // Display overall auto-mapping success message
    displayMessage(scanMessage, `<i class="fas fa-check-circle mr-2"></i>Auto-mapping complete. ${autoMappedCount} fields auto-mapped. Review and adjust if needed.`, 'success', true);
}

/**
 * Adds or updates an "Auto-Matched" badge to the group header.
 * @param {HTMLElement} groupHeaderElement - The H3 element of the group.
 * @param {'learned'|'fuzzy'|'unmapped'} type - The type of mapping.
 * @param {string} [scoreText=''] - Optional score text for fuzzy matches.
 */
function updateBadgeForGroup(groupHeaderElement, type, scoreText = '') {
    let badge = groupHeaderElement.querySelector('.auto-mapped-badge');
    if (!badge) {
        badge = document.createElement('span');
        badge.className = 'auto-mapped-badge';
        groupHeaderElement.appendChild(badge);
    }
    
    // Remove all type classes first to ensure only the current one is applied
    badge.classList.remove('learned', 'fuzzy', 'unmapped');
    // Add the current type class
    badge.classList.add(type);

    // Apply dark mode class to the badge if the body is in dark mode
    if (document.body.classList.contains('dark')) {
        badge.classList.add('dark');
    } else {
        badge.classList.remove('dark');
    }

    let badgeText = '';
    if (type === 'learned') {
        badgeText = 'Auto-Matched (Learned)';
    } else if (type === 'fuzzy') {
        badgeText = `Auto-Matched (Score: ${scoreText})`;
    } else { // 'unmapped'
        badgeText = 'Unmapped';
    }
    badge.textContent = badgeText;

    // Hide badge if unmapped or no selection in the dropdown
    const selectElement = groupHeaderElement.parentElement.querySelector('.group-mapper');
    if (type === 'unmapped' || (selectElement && !selectElement.value)) {
        badge.classList.add('hidden');
    } else {
        badge.classList.remove('hidden');
    }
}

/**
 * Removes the auto-mapped badge from a group header.
 * @param {HTMLElement} groupHeaderElement - The H3 element of the group.
 */
function removeAutoMappedBadge(groupHeaderElement) {
    const badge = groupHeaderElement.querySelector('.auto-mapped-badge');
    if (badge) {
        badge.classList.add('hidden'); // Simply hide it
    }
}

/**
 * Saves the currently selected mappings to chrome.storage.sync for future use.
 */
async function saveLearnedMappings() {
    const currentMappings = {};
    mappingContainer.querySelectorAll('.group-checkbox:checked').forEach(checkbox => {
        const contextKey = checkbox.dataset.contextKey;
        const selectElement = mappingContainer.querySelector(`.group-mapper[data-context-key="${contextKey}"]`);
        const mappedColumnHeader = selectElement ? selectElement.value : '';
        if (mappedColumnHeader) {
            currentMappings[contextKey] = mappedColumnHeader;
        }
    });

    try {
        await chrome.storage.sync.set({ learnedMappings: currentMappings });
        console.log('Learned mappings saved:', currentMappings);
        // After saving, re-run autoMapFields to update badges based on newly learned mappings
        if (Object.keys(groupedFormFields).length > 0 && headers.length > 0) {
            autoMapFields(groupedFormFields, headers); // This will update "learned" badges
        }
    } catch (error) {
        console.error('Error saving learned mappings:', error);
    }
}

/**
 * Loads learned mappings from chrome.storage.sync.
 */
async function loadLearnedMappings() {
    try {
        const result = await chrome.storage.sync.get('learnedMappings');
        learnedMappings = result.learnedMappings || {};
        console.log('Learned mappings loaded:', learnedMappings);
    } catch (error) {
        console.error('Error loading learned mappings:', error);
    }
}

/**
 * Sends a message to the content script to fill the fields on the active tab.
 * This function now iterates through spreadsheet rows and prepares a batch for filling.
 * @param {boolean} isAutoFill - True if triggered by the "One-Click Autofill" button (implies auto-mapping first).
 */
async function fillDataInTab(isAutoFill = false) {
    if (!workbook || sheetData.length <= 1) { // sheetData includes headers, so >1 means actual data rows
        displayMessage(fillDataMessage, '<i class="fas fa-exclamation-triangle mr-2"></i>Please upload a spreadsheet file first.', 'error', true);
        return;
    }
    if (Object.keys(groupedFormFields).length === 0) {
        displayMessage(fillDataMessage, '<i class="fas fa-exclamation-triangle mr-2"></i>Please scan for fields on the current tab first.', 'error', true);
        return;
    }

    // If triggered by "One-Click Autofill", perform scan and auto-map first
    if (isAutoFill) {
        displayMessage(fillDataMessage, '<i class="fas fa-spinner fa-spin mr-2"></i>Performing One-Click Autofill (scanning and auto-mapping)...', 'info', true);
        await scanCurrentTabFields(); // This will also call autoMapFields internally
        if (Object.keys(groupedFormFields).length === 0) {
            displayMessage(fillDataMessage, '<i class="fas fa-exclamation-triangle mr-2"></i>One-Click Autofill failed: No fields found after scan.', 'error', true);
            return;
        }
    }

    const actualDataRows = sheetData.slice(1); // Get data rows, excluding headers

    const fillEmptyOnly = fillEmptyOnlyCheckbox.checked;
    
    // Collect all selected mappings: { contextKey: mappedColumnHeader }
    const selectedMappings = {};
    mappingContainer.querySelectorAll('.group-checkbox:checked').forEach(checkbox => {
        const contextKey = checkbox.dataset.contextKey;
        const selectElement = mappingContainer.querySelector(`.group-mapper[data-context-key="${contextKey}"]`);
        const mappedColumnHeader = selectElement ? selectElement.value : '';
        if (mappedColumnHeader) {
            selectedMappings[contextKey] = mappedColumnHeader;
        }
    });

    if (Object.keys(selectedMappings).length === 0) {
        displayMessage(fillDataMessage, '<i class="fas fa-info-circle mr-2"></i>No fields selected for filling or no column mapped to selected groups.', 'error', true);
        return;
    }

    displayMessage(fillDataMessage, '<i class="fas fa-spinner fa-spin mr-2"></i>Preparing data for filling...', 'info', true);
    // Disable buttons to prevent multiple submissions
    fillDataButton.disabled = true;
    fillDataButton.innerHTML = 'Filling... <span class="loading-spinner"></span>';
    oneClickAutofillButton.disabled = true;
    oneClickAutofillButton.innerHTML = 'One-Click Autofill... <span class="loading-spinner"></span>';
    testFillButton.disabled = true;
    previewValuesButton.disabled = true;

    try {
        const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });
        if (!tab) {
            displayMessage(fillDataMessage, 'Could not get active tab.', 'error', false);
            return;
        }

        const dataBatch = []; // This will hold all field-value pairs to send to content.js

        // Iterate through each data row from the spreadsheet
        actualDataRows.forEach((spreadsheetRow, rowIndex) => {
            // For each mapped field type (contextKey), try to find and prepare data for its instances
            for (const contextKey in selectedMappings) {
                const mappedColumnHeader = selectedMappings[contextKey];
                const columnIndex = headers.indexOf(mappedColumnHeader);

                if (columnIndex !== -1) {
                    // Get all field instances for this group
                    const fieldsInThisGroup = groupedFormFields[contextKey];
                    // IMPORTANT: Assuming sequential filling. Target the Nth instance for the Nth spreadsheet row.
                    // If a form has multiple instances of the same field group, this fills them in order.
                    const targetField = fieldsInThisGroup[rowIndex]; 

                    if (targetField) {
                        const value = spreadsheetRow[columnIndex];
                        // Ensure value is converted to a string for form filling consistency
                        dataBatch.push({
                            id: targetField.id,
                            value: (value !== undefined && value !== null) ? String(value) : ''
                        });
                    } else {
                        // Log a warning if a corresponding form field instance isn't found for a spreadsheet row
                        console.warn(`No form field instance found for group "${contextKey}" at form row index ${rowIndex}. This spreadsheet row might not have a corresponding form field instance.`);
                    }
                } else {
                    // Log a warning if a mapped column header is not found in the spreadsheet headers
                    console.warn(`Mapped column "${mappedColumnHeader}" not found in headers for group "${contextKey}". Skipping.`);
                }
            }
        });

        if (dataBatch.length === 0) {
            displayMessage(fillDataMessage, '<i class="fas fa-info-circle mr-2"></i>No data prepared for filling based on current mappings and spreadsheet data. Check your mappings and file content.', 'info', true);
            return;
        }

        displayMessage(fillDataMessage, `<i class="fas fa-paper-plane mr-2"></i>Sending ${dataBatch.length} fields for filling...`, 'info', true);

        // Send the entire prepared batch to the content script for filling
        const response = await chrome.tabs.sendMessage(tab.id, {
            action: 'fillBatch',
            dataBatch: dataBatch, // Array of {id, value} pairs
            fillEmptyOnly: fillEmptyOnly
        });

        if (response && response.status === 'success') {
            displayMessage(fillDataMessage, `<i class="fas fa-check-circle mr-2"></i>Data filling complete! ${response.filledCount} fields filled, ${response.skippedCount} fields skipped.`, 'success', true);
            saveLearnedMappings(); // Save successful mappings for future use
        } else {
            console.error(`Error filling data: ${response?.message || 'Unknown error.'}`);
            displayMessage(fillDataMessage, `<i class="fas fa-exclamation-triangle mr-2"></i>Error filling data: ${response?.message || 'Unknown error.'}`, "error", true);
        }

    } catch (error) {
        console.error("Error filling data:", error);
        displayMessage(fillDataMessage, `<i class="fas fa-exclamation-triangle mr-2"></i>Error filling data: ${error.message}.`, 'error', true);
    } finally {
        // Re-enable buttons regardless of success or failure
        fillDataButton.disabled = false;
        fillDataButton.innerHTML = '<i class="fas fa-paper-plane mr-2"></i>Fill Data';
        oneClickAutofillButton.disabled = false;
        oneClickAutofillButton.innerHTML = '<i class="fas fa-magic mr-2"></i>One-Click Autofill (Auto-Map & Fill)';
        testFillButton.disabled = false;
        previewValuesButton.disabled = false;
    }
}

/**
 * Fills only the first row of data for testing purposes.
 */
async function testFillFirstRow() {
    if (!workbook || sheetData.length <= 1) {
        displayMessage(testFillMessage, '<i class="fas fa-exclamation-triangle mr-2"></i>Please upload a spreadsheet file with data first.', 'error', true);
        return;
    }
    if (Object.keys(groupedFormFields).length === 0) {
        displayMessage(testFillMessage, '<i class="fas fa-exclamation-triangle mr-2"></i>Please scan for fields on the current tab first.', 'error', true);
        return;
    }

    const firstDataRow = sheetData[1]; // Get the first data row (index 1 after headers)
    if (!firstDataRow) {
        displayMessage(testFillMessage, '<i class="fas fa-info-circle mr-2"></i>No data rows found in the spreadsheet for testing.', 'error', true);
        return;
    }

    const fillEmptyOnly = fillEmptyOnlyCheckbox.checked;
    const dataToFillForFirstRow = [];

    const selectedMappings = {};
    mappingContainer.querySelectorAll('.group-checkbox:checked').forEach(checkbox => {
        const contextKey = checkbox.dataset.contextKey;
        const selectElement = mappingContainer.querySelector(`.group-mapper[data-context-key="${contextKey}"]`);
        const mappedColumnHeader = selectElement ? selectElement.value : '';
        if (mappedColumnHeader) {
            selectedMappings[contextKey] = mappedColumnHeader;
        }
    });

    if (Object.keys(selectedMappings).length === 0) {
        displayMessage(testFillMessage, '<i class="fas fa-info-circle mr-2"></i>No fields selected for test filling or no column mapped.', 'error', true);
        return;
    }

    // Prepare data for the first form "row" based on the first spreadsheet data row
    for (const contextKey in selectedMappings) {
        const mappedColumnHeader = selectedMappings[contextKey];
        const columnIndex = headers.indexOf(mappedColumnHeader);

        if (columnIndex !== -1) {
            const fieldsInThisGroup = groupedFormFields[contextKey];
            const targetField = fieldsInThisGroup[0]; // Target the first instance of this grouped field for test fill
            if (targetField) {
                const value = firstDataRow[columnIndex];
                dataToFillForFirstRow.push({
                    id: targetField.id,
                    value: (value !== undefined && value !== null) ? String(value) : ''
                });
            } else {
                console.warn(`No form field instance found for group "${contextKey}" at form row index 0 for test fill.`);
            }
        }
    }

    if (dataToFillForFirstRow.length === 0) {
        displayMessage(testFillMessage, '<i class="fas fa-info-circle mr-2"></i>No data prepared for test filling based on current mappings and first spreadsheet row. Check your mappings.', 'info', true);
        return;
    }

    displayMessage(testFillMessage, '<i class="fas fa-spinner fa-spin mr-2"></i>Performing test fill for the first row...', 'info', true);
    testFillButton.disabled = true;
    testFillButton.innerHTML = 'Testing... <span class="loading-spinner"></span>';

    try {
        const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });
        if (!tab) {
            displayMessage(testFillMessage, 'Could not get active tab.', 'error', false);
            return;
        }

        const response = await chrome.tabs.sendMessage(tab.id, {
            action: 'fillBatch',
            dataBatch: dataToFillForFirstRow,
            fillEmptyOnly: fillEmptyOnly
        });

        if (response && response.status === 'success') {
            displayMessage(testFillMessage, `<i class="fas fa-check-circle mr-2"></i>Test fill complete! ${response.filledCount} fields filled, ${response.skippedCount} fields skipped for the first row.`, 'success', true);
        } else {
            console.error(`Error during test fill: ${response?.message || 'Unknown error.'}`);
            displayMessage(testFillMessage, `<i class="fas fa-exclamation-triangle mr-2"></i>Error during test fill: ${response?.message || 'Unknown error.'}`, "error", true);
        }

    } catch (error) {
        console.error("Error during test fill:", error);
        displayMessage(testFillMessage, `<i class="fas fa-exclamation-triangle mr-2"></i>Error during test fill: ${error.message}.`, 'error', true);
    } finally {
        testFillButton.disabled = false;
        testFillButton.innerHTML = '<i class="fas fa-vial mr-2"></i>Test Fill First Row';
    }
}

/**
 * Displays a preview of mapped values for the first data row.
 */
function previewMappedValues() {
    if (!workbook || sheetData.length <= 1) {
        displayMessage(previewValuesMessage, '<i class="fas fa-exclamation-triangle mr-2"></i>Please upload a spreadsheet file with data first.', 'error', true);
        return;
    }
    if (Object.keys(groupedFormFields).length === 0) {
        displayMessage(previewValuesMessage, '<i class="fas fa-exclamation-triangle mr-2"></i>Please scan for fields on the current tab first.', 'error', true);
        return;
    }

    const firstDataRow = sheetData[1];
    if (!firstDataRow) {
        displayMessage(previewValuesMessage, '<i class="fas fa-info-circle mr-2"></i>No data rows found in the spreadsheet for preview.', 'info', true);
        return;
    }

    const selectedMappings = {};
    mappingContainer.querySelectorAll('.group-checkbox:checked').forEach(checkbox => {
        const contextKey = checkbox.dataset.contextKey;
        const selectElement = mappingContainer.querySelector(`.group-mapper[data-context-key="${contextKey}"]`);
        const mappedColumnHeader = selectElement ? selectElement.value : '';
        if (mappedColumnHeader) {
            selectedMappings[contextKey] = mappedColumnHeader;
        }
    });

    if (Object.keys(selectedMappings).length === 0) {
        displayMessage(previewValuesMessage, '<i class="fas fa-info-circle mr-2"></i>No fields selected for preview or no column mapped.', 'info', true);
        return;
    }

    let previewHtml = '<p class="font-semibold mb-2">Preview for First Data Row:</p>';
    previewHtml += '<ul class="list-disc list-inside text-left">';

    let hasPreviewData = false;
    for (const contextKey in selectedMappings) {
        const mappedColumnHeader = selectedMappings[contextKey];
        const columnIndex = headers.indexOf(mappedColumnHeader);

        if (columnIndex !== -1) {
            const fieldsInThisGroup = groupedFormFields[contextKey];
            const targetField = fieldsInThisGroup[0]; // Preview for the first instance of this grouped field
            if (targetField) {
                const value = firstDataRow[columnIndex];
                let displayName = targetField.labelText || targetField.name || targetField.placeholder || 'Unnamed Field';
                displayName = displayName.replace(/\[\d+\]/g, '').trim();
                if (displayName.startsWith('stable-id-')) displayName = 'Unnamed Field Instance';

                previewHtml += `<li><strong>${displayName}</strong> (mapped to "${mappedColumnHeader}"): <code>${(value !== undefined && value !== null) ? String(value) : '[Empty]'}</code></li>`;
                hasPreviewData = true;
            }
        }
    }
    previewHtml += '</ul>';

    if (hasPreviewData) {
        displayMessage(previewValuesMessage, previewHtml, 'info', true); // Pass true for raw HTML
    } else {
        displayMessage(previewValuesMessage, '<i class="fas fa-info-circle mr-2"></i>No preview data available based on current selections. Select some fields and map columns.', 'info', true);
    }
}


/**
 * Displays a temporary message in a designated message box.
 * @param {HTMLElement} element - The message box element (e.g., scanMessage, fillDataMessage).
 * @param {string} message - The message content (can be HTML if isHtml is true).
 * @param {'success'|'error'|'info'} type - The type of message for styling.
 * @param {boolean} isHtml - If true, message is parsed as HTML; otherwise, as plain text.
 */
function displayMessage(element, message, type, isHtml = false) {
    if (isHtml) {
        element.innerHTML = message;
    } else {
        element.textContent = message;
    }
    // Apply base class and type-specific class
    element.className = `message-box mt-3 ${type === 'success' ? 'message-success' : type === 'error' ? 'message-error' : 'message-info'}`;
    element.classList.remove('hidden');

    // Apply dark mode class based on current body theme
    if (document.body.classList.contains('dark')) {
        element.classList.add('dark');
    } else {
        element.classList.remove('dark');
    }

    // Set a timeout to hide the message, with a longer duration for preview messages
    const duration = element.id === 'previewValuesMessage' ? 10000 : 5000;
    setTimeout(() => {
        element.classList.add('hidden');
        element.innerHTML = ''; // Clear content when hidden
    }, duration);
}

/**
 * Displays a temporary message in the specific fileStatusMessage element.
 * This is a specialized version of displayMessage for the file upload status.
 * @param {string} message - The message content (can be HTML if isHtml is true).
 * @param {'success'|'error'|'info'} type - The type of message for styling.
 * @param {HTMLElement} element - The specific element to display the message (e.g., fileStatusMessage)
 * @param {boolean} isHtml - If true, message is parsed as HTML; otherwise, as plain text.
 */
function displayFileStatusMessage(message, type, element, isHtml = false) {
    if (isHtml) {
        fileMessage.innerHTML = message;
    } else {
        fileMessage.textContent = message;
    }

    element.classList.remove('hidden');
    element.className = 'file-status mt-4'; // Reset class for styling
    element.classList.add(`message-${type}`);

    // Set icon based on message type
    if (type === 'success') {
        fileStatusIcon.className = 'fas fa-check-circle text-xl mr-3';
    } else if (type === 'error') {
        fileStatusIcon.className = 'fas fa-exclamation-circle text-xl mr-3';
    } else if (type === 'info') {
        fileStatusIcon.className = 'fas fa-spinner fa-spin text-xl mr-3';
    }

    // Apply dark mode class if body is dark
    if (document.body.classList.contains('dark')) {
        element.classList.add('dark');
    } else {
        element.classList.remove('dark');
    }

    // Hide after 5 seconds (standard duration for file status)
    setTimeout(() => {
        element.classList.add('hidden');
        fileMessage.innerHTML = ''; // Clear content when hidden
        fileStatusIcon.className = ''; // Clear icon
    }, 5000); 
}


--- END FILE: popup.js ---

----------------------------------------------------------------------------------------------------------------------------------

do the following please:

the problem i'm facing now are with the buttons being of wrong size and the distance between one button and the other(like in "fill data" button and "one-click auto fill" button). i also want to make it visually more attractive and precise.