Okay, I understand. The goal is to make the dark mode experience more polished and visually appealing, specifically addressing elements that might still appear too light or have insufficient contrast.

The core issue likely lies in how the dark mode classes are applied and how the CSS variables are used for dynamically generated elements. I'll refine the dark mode color palette for better contrast and ensure that all relevant elements correctly inherit or apply dark mode styles.

Here's a summary of the specific changes I'm making:

CSS Variable Scope:

Changed :root to html for defining CSS variables, making it more explicit that these are global document-level variables.
Changed body.dark selectors to html.dark throughout popup.css to ensure consistent dark mode application at the root level.
Dark Mode Palette Refinements:

Background (--bg-color-dark): Changed from slate-900 (#1e293b) to a slightly deeper slate-950 (#0f172a) to provide a richer dark background.
Text Color (--text-color-dark): Made it slightly lighter for better contrast: #e2e8f0 (slate-200).
Card Background (--card-bg-dark): Will remain slate-700 (#334155) to provide a good, discernible contrast with the new deeper body background.
Selected Item Highlight (--selected-item-highlight-bg-dark): Introduced new variables for the background and border color of selected items in dark mode, moving away from light-mode blues to a darker indigo.
Dynamic Element Theming in popup.js:

Global Theme Toggle: Ensured document.documentElement.classList.toggle('dark', isDarkMode) is used for applying the dark class to the html element, which correctly triggers CSS variable changes.
Headers List (headersDisplayElem): Modified displayHeaders to explicitly add/remove the dark class to each dynamically created span element, so they pick up the headers-list span.dark styles.
Clickable Buttons (clickableButtonsContainer): Ensured the selected-button-highlight class on clickable elements also correctly toggles the dark class to apply its specific dark mode highlight styles.
Generic Message Boxes (displayMessage and displayFileStatusMessage): Ensured these functions correctly toggle the dark class on the message elements themselves, allowing their .message-success.dark, .message-error.dark, etc., styles to apply.
CSS Rules Refinement:

Added explicit .dark class variants for elements where the theme might not propagate purely through inheritance (e.g., headers-list span.dark, selected-button-highlight.dark).
Adjusted hover shadows and colors for buttons in dark mode for a more distinct and appealing effect.
These changes should significantly improve the visual quality and responsiveness of the dark mode, making elements with text on them more legible and integrated into the dark theme.

Here are all the updated files:

--- START FILE: combine_project.py ---

import os

def combine_files_to_single_file(root_dir, output_filename="combined_project_files.txt"):
    """
    Combines the content of all files in a directory into a single file,
    excluding 'node_modules' directories and 'package-lock.json' files.

    Args:
        root_dir (str): The root directory of the project.
        output_filename (str): The name of the output file.
    """
    combined_content = []
    excluded_dirs = ['node_modules', '.git', '.vscode', '.idea', 'dist', 'build']
    excluded_files = ['package-lock.json', 'yarn.lock', 'bun.lockb', '.env', 'xlsx.full.min.js'] # Added .env as it might contain sensitive info

    print(f"Starting to combine files from: {root_dir}")
    print(f"Excluding directories: {excluded_dirs}")
    print(f"Excluding files: {excluded_files}")

    for dirpath, dirnames, filenames in os.walk(root_dir):
        # Modify dirnames in-place to skip excluded directories
        dirnames[:] = [d for d in dirnames if d not in excluded_dirs]

        for filename in filenames:
            if filename in excluded_files:
                print(f"Skipping excluded file: {os.path.join(dirpath, filename)}")
                continue

            file_path = os.path.join(dirpath, filename)
            # Make path relative to root_dir for the header
            relative_file_path = os.path.relpath(file_path, root_dir)

            try:
                with open(file_path, 'r', encoding='utf-8') as f:
                    content = f.read()
                
                combined_content.append(f"\n--- START FILE: {relative_file_path} ---\n\n")
                combined_content.append(content)
                combined_content.append(f"\n\n--- END FILE: {relative_file_path} ---\n")
                print(f"Included file: {relative_file_path}")
            except UnicodeDecodeError:
                print(f"Skipping binary or undecodable file (UnicodeDecodeError): {relative_file_path}")
            except Exception as e:
                print(f"Error reading file {relative_file_path}: {e}")

    output_path = os.path.join(root_dir, output_filename)
    try:
        with open(output_path, 'w', encoding='utf-8') as outfile:
            outfile.write("".join(combined_content))
        print(f"\nSuccessfully combined all files into: {output_path}")
    except Exception as e:
        print(f"Error writing output file {output_path}: {e}")

if __name__ == "__main__":
    # Get the current working directory where the script is run
    # This assumes you run the script from your project's root directory
    project_root = os.getcwd()
    combine_files_to_single_file(project_root)
--- END FILE: combine_project.py ---

--- START FILE: content.js ---

/**
 * content.js
 * This script runs in the context of the web page.
 * It listens for messages from the extension's popup and performs DOM manipulations.
 */

// Global flag to ensure message listener is added only once per script execution context
// This helps prevent stacking listeners if the content script is executed multiple times
// without the page fully reloading.
let listenerInitialized = false;

// Global error handler for better debugging in the content script context
window.onerror = function (msg, url, lineNo, columnNo, error) {
    console.error('Global Error (content.js):', { msg, url, lineNo, columnNo, error });
    // In a production extension, you might send this error to a background script or a logging service.
};

// Listen for messages from the popup script
// This listener will only be added once due to the listenerInitialized check
if (!listenerInitialized) {
    chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
        // Handle a 'ping' action to confirm the content script is loaded
        if (request.action === "ping") {
            sendResponse({ status: "pong" });
            return true; // Indicate that the response will be sent asynchronously
        }
        else if (request.action === 'scanFields') {
            const fields = scanForFormFields();
            sendResponse({ fields: fields });
            return true; // Keep the message channel open for async response
        } else if (request.action === 'fillBatch') { // Handle batched filling
            const { dataBatch, fillEmptyOnly } = request;
            const result = fillFormFieldsBatch(dataBatch, fillEmptyOnly);
            sendResponse(result);
            return true; // Keep the message channel open for async response
        } else if (request.action === "scanClickables") { // Handle scanClickables
            const elements = getClickableElements();
            sendResponse({ clickables: elements });
            return true; // Keep the message channel open for async response
        } else if (request.action === "performClick") { // Handle performClick
            // Call the async function and then send the response
            clickElementByStableId(request.stableId, request.count).then(result => {
                sendResponse({
                    status: result.success ? "success" : "error",
                    message: result.message || ""
                });
            }).catch(error => {
                console.error("Error in performClick promise chain:", error);
                sendResponse({ status: "error", message: `Internal error during click: ${error.message}` });
            });
            return true; // This is crucial: indicates that sendResponse will be called asynchronously
        }
        // If no action matched, return false or nothing for synchronous handling
        return false;
    });
    listenerInitialized = true; // Set flag to true after listener is added
}


/**
 * Scans the current web page for input fields, textareas, and select elements.
 * Gathers relevant information about each field, including enhanced metadata and a grouping context.
 * @returns {Array<Object>} An array of objects, each representing a form field.
 */
function scanForFormFields() {
    const fields = [];
    // Select all relevant form elements, excluding hidden, submit, button, and reset types.
    const elements = document.querySelectorAll('input:not([type="hidden"]):not([type="submit"]):not([type="button"]):not([type="reset"]), textarea, select');

    elements.forEach((element, index) => {
        // Generate a more stable and readable ID if the element doesn't have one.
        // Prioritize existing ID, then name, then placeholder, then a generated stable ID.
        let fieldId = element.id || element.name || element.placeholder || `stable-id-${index}-${Date.now()}`;
        // Ensure the ID is unique and valid for DOM selection
        if (!element.id) {
            // Make sure the generated ID is unique on the page if it's not already
            let tempId = fieldId;
            let counter = 0;
            while (document.getElementById(tempId)) {
                tempId = `${fieldId}-${counter++}`;
            }
            element.id = tempId; // Assign the unique ID to the DOM element
            fieldId = tempId; // Use this new unique ID for our field object
        }

        let labelText = '';

        // --- Prioritize table headers (<th>) for fields inside table cells (<td>) ---
        let currentCell = element.closest('td');
        if (currentCell) {
            const table = currentCell.closest('table');
            if (table) {
                const cellIndex = Array.from(currentCell.parentElement.children).indexOf(currentCell);
                // Try to find a corresponding <th> in the same column within the table's thead
                const headerCell = table.querySelector(`thead tr th:nth-child(${cellIndex + 1})`);
                if (headerCell && headerCell.textContent.trim().length > 0) {
                    labelText = headerCell.textContent.trim();
                }
            }
        }

        // Prioritize more direct and semantic labels if table header not found or empty
        if (!labelText) {
            if (element.getAttribute('aria-label')) {
                labelText = element.getAttribute('aria-label').trim();
            } else if (element.placeholder) {
                labelText = element.placeholder.trim();
            } else if (element.title) {
                labelText = element.title.trim();
            } else if (element.name) {
                // Clean up name attribute if it contains array-like indexing
                labelText = element.name.replace(/\[\d+\]/g, '').trim();
            }
        }

        // Fallback to finding an associated label using 'for' attribute
        if (!labelText && element.id) {
            const label = document.querySelector(`label[for="${element.id}"]`);
            if (label) {
                labelText = label.textContent.trim();
            }
        }

        // If no 'for' label, check parent elements for label text or aria-label
        if (!labelText) {
            let parent = element.parentElement;
            while (parent && parent.tagName !== 'BODY') {
                // Check for a <label> element that contains the current element
                const potentialLabel = parent.querySelector(`label:has(#${element.id})`); // Using :has() for more accurate containment
                if (potentialLabel) {
                    labelText = potentialLabel.textContent.trim();
                    break;
                }
                // Check for a label or text directly within the parent that might serve as a label
                const parentText = Array.from(parent.childNodes)
                    .filter(node => node.nodeType === Node.TEXT_NODE && node.textContent.trim().length > 0)
                    .map(node => node.textContent.trim())
                    .join(' ');
                if (parentText) {
                    labelText = parentText;
                    break;
                }
                parent = parent.parentElement;
            }
        }
        
        // --- Collect more metadata for intelligent auto-mapping and grouping context ---
        let surroundingText = '';

        // Prioritize text from immediate previous sibling elements that might be headings or prominent labels
        let prevSibling = element.previousElementSibling;
        while (prevSibling && (prevSibling.tagName === 'LABEL' || prevSibling.tagName === 'P' || prevSibling.tagName === 'DIV' || prevSibling.tagName.match(/^H[1-6]$/))) {
            const text = prevSibling.textContent.trim();
            if (text.length > 0) {
                surroundingText = text + ' ' + surroundingText;
            }
            // Stop if we hit a non-text/label/heading element or a form boundary
            if (!prevSibling.previousElementSibling || prevSibling.previousElementSibling.tagName === 'FORM' || prevSibling.previousElementSibling.tagName === 'fieldset' || prevSibling.previousElementSibling.tagName === 'SECTION') {
                break;
            }
            prevSibling = prevSibling.previousElementSibling;
        }

        // Also check parent elements for prominent text/labels, especially for table headers (re-check if not already found)
        if (!surroundingText && currentCell) { // Only if we are in a table cell and surroundingText is still empty
            const table = currentCell.closest('table');
            if (table) {
                const cellIndex = Array.from(currentCell.parentElement.children).indexOf(currentCell);
                const headerCell = table.querySelector(`thead tr th:nth-child(${cellIndex + 1})`);
                if (headerCell && headerCell.textContent.trim().length > 0) {
                    surroundingText = headerCell.textContent.trim();
                }
            }
        }

        // Check for general parent text/labels if still no strong context
        let currentParent = element.parentElement;
        while (currentParent && currentParent.tagName !== 'BODY') {
            const parentLabel = currentParent.querySelector('label');
            if (parentLabel && parentLabel.textContent.trim().length > 0 && !surroundingText.includes(parentLabel.textContent.trim())) {
                surroundingText = parentLabel.textContent.trim() + ' ' + surroundingText;
            }

            const parentHeading = currentParent.querySelector('h1, h2, h3, h4, h5, h6');
            if (parentHeading && parentHeading.textContent.trim().length > 0 && !surroundingText.includes(parentHeading.textContent.trim())) {
                surroundingText = parentHeading.textContent.trim() + ' ' + surroundingText;
            }

            Array.from(currentParent.childNodes).forEach(node => {
                if (node.nodeType === Node.TEXT_NODE && node.textContent.trim().length > 0 && !surroundingText.includes(node.textContent.trim())) {
                    surroundingText += node.textContent.trim() + ' ';
                }
            });

            currentParent = currentParent.parentElement;
        }
        surroundingText = surroundingText.trim();

        // Fallback to labelText if surroundingText is still empty
        if (!surroundingText && labelText) {
            surroundingText = labelText;
        }
        // Fallback to placeholder if still no context
        if (!surroundingText && element.placeholder) {
            surroundingText = element.placeholder.trim();
        }
        // Fallback to name if still no context
        if (!surroundingText && element.name) {
            surroundingText = element.name.trim();
        }

        fields.push({
            id: fieldId, // Internal unique ID for the element (now more stable)
            name: element.name || '',
            type: element.type || element.tagName.toLowerCase(),
            value: element.value || '', // Current value of the field
            labelText: labelText, // Best guess for a user-friendly label
            htmlId: element.id, // Explicitly store the ID
            placeholder: element.placeholder || '',
            ariaLabel: element.getAttribute('aria-label') || '',
            className: element.className || '', // All classes as a string
            dataset: element.dataset ? JSON.parse(JSON.stringify(element.dataset)) : {}, // Convert DOMStringMap to plain object
            surroundingText: surroundingText, // This will now be our primary grouping key
            autocomplete: element.getAttribute('autocomplete') || '', // HTML autocomplete attribute
            role: element.getAttribute('role') || '', // ARIA role attribute
            title: element.getAttribute('title') || '' // HTML title attribute
        });
    });
    return fields;
}

/**
 * Fills a batch of specified form fields with data.
 * @param {Array<Object>} dataBatch - An array of objects, where each object is { fieldId: valueToFill }.
 * @param {boolean} fillEmptyOnly - If true, only fill fields that are currently empty.
 * @returns {Object} An object with status, filled count, and skipped count.
 */
function fillFormFieldsBatch(dataBatch, fillEmptyOnly) {
    let filledCount = 0;
    let skippedCount = 0;

    dataBatch.forEach(fieldData => {
        const fieldId = fieldData.id; // Use 'id' as the key for the field element
        const valueToFill = fieldData.value; // Use 'value' as the value to fill

        const element = document.getElementById(fieldId);

        if (element) {
            const currentFieldValue = element.value;

            // Check if the field should be skipped based on fillEmptyOnly flag
            if (fillEmptyOnly && currentFieldValue.trim() !== '') {
                skippedCount++;
                return; // Continue to the next item in the batch
            }

            // Fill the field based on its type
            if (element.tagName === 'INPUT' || element.tagName === 'TEXTAREA') {
                element.value = valueToFill;
                // Dispatch input/change events to trigger any framework listeners
                element.dispatchEvent(new Event('input', { bubbles: true }));
                element.dispatchEvent(new Event('change', { bubbles: true }));
                filledCount++;
            } else if (element.tagName === 'SELECT') {
                // For select elements, try to find an option with the matching value
                let optionFound = false;
                for (let i = 0; i < element.options.length; i++) {
                    // Match by value or by text content
                    if (element.options[i].value === valueToFill || element.options[i].textContent === valueToFill) {
                        element.value = element.options[i].value;
                        optionFound = true;
                        break;
                    }
                }
                if (optionFound) {
                    element.dispatchEvent(new Event('change', { bubbles: true }));
                    filledCount++;
                } else {
                    console.warn(`Select element with ID "${fieldId}" has no option for value "${valueToFill}".`);
                    skippedCount++; // Consider this skipped if value not found
                }
            } else {
                console.warn(`Unsupported field type for element with ID "${fieldId}".`);
                skippedCount++;
            }
        } else {
            console.warn(`Element with ID "${fieldId}" not found on the page.`);
            skippedCount++;
        }
    });

    return { status: 'success', filledCount: filledCount, skippedCount: skippedCount };
}

/**
 * Scans the current web page for clickable elements.
 * @returns {Array<Object>} An array of objects, each representing a clickable element.
 */
function getClickableElements() {
    // Select common clickable elements: buttons, input type="button", links with href, and elements with role="button"
    const buttons = [...document.querySelectorAll('button, input[type="button"], a[href], [role="button"], [onclick], [tabindex="0"][aria-pressed], [tabindex="0"][aria-expanded], [tabindex="0"][role]:not([role="textbox"]):not([role="searchbox"]):not([role="combobox"]):not([role="slider"])')];
    
    // Filter out hidden elements, and elements that are likely part of other controls (like text inputs within a search button container)
    const filteredButtons = buttons.filter(el => {
        const style = window.getComputedStyle(el);
        const isVisible = style.display !== 'none' && style.visibility !== 'hidden' && style.opacity !== '0';
        const rect = el.getBoundingClientRect();
        const hasSize = rect.width > 0 && rect.height > 0;
        
        // Exclude elements that are disabled or have a disabled attribute
        if (el.disabled || el.getAttribute('aria-disabled') === 'true') {
            return false;
        }

        // Exclude inputs that are not explicitly buttons
        if (el.tagName === 'INPUT' && el.type !== 'button' && el.type !== 'submit' && el.type !== 'reset') {
            return false;
        }

        // Exclude links that are just anchors with no real action (e.g., # or javascript:void(0))
        if (el.tagName === 'A' && (!el.href || el.href.trim() === '#' || el.href.startsWith('javascript:void(0)'))) {
            return false;
        }

        return isVisible && hasSize;
    });

    return filteredButtons.map((el, index) => {
        // Prefer text content, then aria-label, then title for a human-readable label
        const text = el.innerText?.trim() || "";
        const aria = el.getAttribute("aria-label")?.trim() || "";
        const title = el.getAttribute("title")?.trim() || "";
        const name = el.getAttribute("name")?.trim() || "";
        const id = el.id?.trim() || "";

        let label = text || aria || title || name || id || `Element #${index + 1}`;
        if (label.length > 50) { // Truncate long labels for display
            label = label.substring(0, 47) + '...';
        }

        // Generate a stable ID for the element if it doesn't have one or if it's not unique
        let stableId = el.id || `autoClick-${index}-${Date.now()}`;
        if (!el.id) {
            // Ensure generated ID is unique on the page
            let tempId = stableId;
            let counter = 0;
            while (document.getElementById(tempId)) {
                tempId = `${stableId}-${counter++}`;
            }
            el.id = tempId; // Assign the generated ID to the element for easier future lookup
            stableId = tempId;
        }
        
        // Add a data attribute for easier direct selection in the content script
        // This ensures a stable way to find the element even if its original ID is dynamically changed
        el.setAttribute("data-auto-click-id", stableId);

        return { text: label, stableId: stableId }; // Return the chosen label and stable ID
    });
}

/**
 * Performs a click on an element identified by its stable ID, with a delay between clicks.
 * @param {string} stableId - The stable ID of the element to click.
 * @param {number} count - The number of times to click the element.
 * @returns {Promise<Object>} A promise that resolves to an object indicating success or failure and a message.
 */
async function clickElementByStableId(stableId, count) {
    // Select using the data-auto-click-id attribute which we assigned
    const target = document.querySelector(`[data-auto-click-id="${stableId}"]`);
    
    if (!target) {
        return { success: false, message: "Target element not found on the page. It might have been removed or changed." };
    }

    try {
        for (let i = 0; i < count; i++) {
            target.click(); // Programmatically perform the click event
            // Introduce a short delay to simulate human interaction and allow DOM to react, especially useful for forms that reload or have animations
            await new Promise(resolve => setTimeout(resolve, 300)); // 300ms delay between clicks
        }
        return { success: true };
    } catch (error) {
        console.error("Error simulating click:", error);
        return { success: false, message: `Error during click simulation: ${error.message}` };
    }
}
--- END FILE: content.js ---

--- START FILE: manifest.json ---

{
    "manifest_version": 3,
    "name": "Spreadsheet Data Filler",
    "version": "1.0",
    "description": "Upload a spreadsheet, map columns to fields on the current tab, and fill them.",
    "permissions": [
        "activeTab",
        "scripting"
    ],
    "action": { 
        "default_popup": "popup.html",
        "default_icon": {
            "16": "icons/icon16.png",
            "48": "icons/icon48.png",
            "128": "icons/icon128.png"
        }
    },
    "icons": {
        "16": "icons/icon16.png",
        "48": "icons/icon48.png",
        "128": "icons/icon128.png"
    },
    "web_accessible_resources": [
        {
            "resources": [ "icons/*.png", "xlsx.full.min.js" ],
            "matches": [ "<all_urls>" ]
        }
    ]
}
--- END FILE: manifest.json ---

--- START FILE: popup.css ---

/* popup.css */

/* Define CSS Variables for theming (Light and Dark Mode) */
html { /* Apply theme variables to html element for broader scope */
  /* Light Mode Colors */
  --bg-color-light: #f8fafc; /* slate-50 */
  --text-color-light: #334155; /* slate-700 */
  --header-text-color-light: #111827; /* Darker gray */
  --card-bg-light: #ffffff; /* White */
  --border-color-light: #e2e8f0; /* slate-200 Light border */

  /* Primary Action Button (Blue) */
  --primary-button-bg-light: #2563eb; /* blue-600 */
  --primary-button-hover-bg-light: #1d4ed8; /* blue-700 */
  --primary-button-border-light: #1e40af; /* Darker blue for subtle border */

  /* Secondary Action Button (Emerald for Scan, gray for general secondary) */
  --secondary-button-bg-light: #6b7280; /* gray-500 */
  --secondary-button-hover-bg-light: #4b5563; /* gray-600 */
  --secondary-button-border-light: #4b5563;
  
  --emerald-button-bg-light: #059669; /* emerald-600 */
  --emerald-button-hover-bg-light: #047857; /* emerald-700 */
  --emerald-button-border-light: #047857;

  --input-border-light: #d1d5db; /* gray-300 */
  --input-focus-ring-light: #60a5fa; /* blue-400 */
  --input-focus-ring-rgb-values-light: 96, 165, 250;

  /* Drop Area */
  --drop-area-border-light: #60a5fa; /* blue-400 */
  --drop-area-bg-light: #eff6ff; /* blue-50 */
  --drop-area-hover-bg-light: #dbeafe; /* blue-100 */
  --drop-area-text-light: #6b7280; /* gray-500 */
  --drop-area-hover-text-light: #1e40af; /* blue-800 */
  
  /* File Status Message */
  --file-status-success-bg-light: #d1fae5; /* green-100 */
  --file-status-success-border-light: #34d399; /* green-400 */
  --file-status-success-text-light: #065f46; /* green-700 */
  --file-status-success-icon-light: #10b981; /* green-500 */

  --file-status-error-bg-light: #fee2e2; /* red-100 */
  --file-status-error-border-light: #f87171; /* red-400 */
  --file-status-error-text-light: #991b1b; /* red-700 */
  --file-status-error-icon-light: #ef4444; /* red-500 */

  --file-status-info-bg-light: #e0f2fe; /* light blue-100 */
  --file-status-info-border-light: #60a5fa; /* blue-400 */
  --file-status-info-text-light: #1e40af; /* blue-700 */
  --file-status-info-icon-light: #3b82f6; /* blue-500 */

  /* Headers List Badges */
  --header-badge-bg-light: #e0e7ff; /* indigo-100 */
  --header-badge-text-light: #3730a3; /* indigo-800 */
  --header-badge-hover-bg-light: #c7d2fe; /* indigo-200 */
  
  /* Auto-Mapped Badges */
  --auto-mapped-learned-bg: #bfdbfe; /* blue-200 */
  --auto-mapped-learned-text: #1e40af; /* blue-800 */
  --auto-mapped-fuzzy-bg: #d1fae5; /* green-200 */
  --auto-mapped-fuzzy-text: #065f46; /* green-800 */
  --auto-mapped-unmapped-bg: #e5e7eb; /* gray-200 */
  --auto-mapped-unmapped-text: #4b5563; /* gray-800 */

  /* Tab Buttons */
  --tab-button-bg: #e5e7eb; /* gray-200 */
  --tab-button-hover-bg: #d1d5db; /* gray-300 */
  --tab-button-active-bg: #ffffff;
  --tab-button-active-text: #2563eb; /* blue-600 */
  --tab-button-text: #4b5563; /* gray-700 */
  
  /* Clickable Elements List (using more generic names now) */
  --list-container-bg-light: #f9fafb; /* gray-50 */
  --list-item-border-light: #e5e7eb; /* gray-200 */
  --list-item-hover-bg-light: #f3f4f6; /* gray-100 */
  --selected-item-highlight-bg-light: #e0f2fe; /* blue-100 */
  --selected-button-highlight-border: #93c5fd; /* blue-300 */

  /* New & Refined Shadows (Light Mode) */
  --main-container-shadow-light: 
    0 15px 30px -10px rgba(0, 0, 0, 0.15), /* Larger, softer base */
    0 8px 15px -5px rgba(0, 0, 0, 0.1);    /* Deeper, more defined */
  --card-shadow-light: 
    0 6px 12px -4px rgba(0, 0, 0, 0.1), /* Slightly larger base for cards */
    0 3px 6px -2px rgba(0, 0, 0, 0.08);   /* More defined top layer */

  --primary-button-shadow-light: 
    0 10px 20px -5px rgba(37, 99, 235, 0.4), /* Primary blue with strong, colored shadow */
    0 4px 6px -2px rgba(37, 99, 235, 0.2);
  --emerald-button-shadow-light: 
    0 10px 20px -5px rgba(5, 150, 105, 0.4), /* Emerald with strong, colored shadow */
    0 4px 6px -2px rgba(5, 150, 105, 0.2);
  --secondary-button-shadow-light: 
    0 8px 15px -4px rgba(107, 114, 128, 0.25), /* Gray with moderate shadow */
    0 3px 5px -1px rgba(107, 114, 128, 0.1);

  --tab-button-active-shadow-light: 
    0 8px 16px rgba(0,0,0,0.15), 
    0 4px 8px rgba(0,0,0,0.1);

  --drop-area-inner-shadow-light: inset 0 2px 4px rgba(0, 0, 0, 0.06);

  --header-badge-shadow-light: 0 2px 4px rgba(0,0,0,0.1);
}

/* Dark Mode Overrides (Default Light Mode values are above) */
html.dark { /* Apply dark theme variables when html has 'dark' class */
  --bg-color-dark: #0f172a; /* slate-950 (deeper dark) */
  --text-color-dark: #e2e8f0; /* slate-200 (lighter for contrast) */
  --header-text-color-dark: #f1f5f9; /* slate-50 */
  --card-bg-dark: #334155; /* slate-700 */
  --border-color-dark: #475569; /* slate-600 */

  --primary-button-bg-dark: #6366f1; /* indigo-500 */
  --primary-button-hover-bg-dark: #4338ca; /* indigo-700 */
  --primary-button-border-dark: #3730a3; /* Darker indigo for subtle border */

  --secondary-button-bg-dark: #4a5568; /* gray-700 */
  --secondary-button-hover-bg-dark: #616e80; /* gray-600 */
  --secondary-button-border-dark: #2d3748;
  
  --emerald-button-bg-dark: #065f46; /* emerald-800 */
  --emerald-button-hover-bg-dark: #047857; /* emerald-700 */
  --emerald-button-border-dark: #047857;

  --input-border-dark: #4a5568; /* gray-700 */
  --input-focus-ring-dark: #818cf8; /* indigo-400 */
  --input-focus-ring-rgb-values-dark: 129, 140, 248;

  --drop-area-border-dark: #6366f1; /* indigo-500 */
  --drop-area-bg-dark: #3730a3; /* indigo-900 */
  --drop-area-hover-bg-dark: #4f46e5; /* indigo-700 */
  --drop-area-text-dark: #a0aec0; /* gray-400 */
  --drop-area-hover-text-dark: #e0e7ff; /* indigo-100 */

  --file-status-success-bg-dark: #065f46; /* green-900 */
  --file-status-success-border-dark: #34d399; /* green-400 */
  --file-status-success-text-dark: #d1fae5; /* green-100 */
  --file-status-success-icon-dark: #10b981; /* green-500 */

  --file-status-error-bg-dark: #7f1d1d; /* red-900 */
  --file-status-error-border-dark: #f87171; /* red-400 */
  --file-status-error-text-dark: #fee2e2; /* red-100 */
  --file-status-error-icon-dark: #ef4444; /* red-500 */

  --file-status-info-bg-dark: #1e3a8a; /* blue-900 */
  --file-status-info-border-dark: #60a5fa; /* blue-400 */
  --file-status-info-text-dark: #e0f2fe; /* blue-100 */
  --file-status-info-icon-dark: #3b82f6; /* blue-500 */

  --header-badge-bg-dark: #4f46e5; /* indigo-600 */
  --header-badge-text-dark: #e0e7ff; /* indigo-100 */
  --header-badge-hover-bg-dark: #4f46e5; /* indigo-600 */

  --auto-mapped-learned-bg: #4c51bf; /* indigo-700 */
  --auto-mapped-learned-text: #e0e7ff; /* indigo-100 */
  --auto-mapped-fuzzy-bg: #14532d; /* green-900 */
  --auto-mapped-fuzzy-text: #dcfce7; /* green-100 */
  --auto-mapped-unmapped-bg: #4a5568; /* gray-700 */
  --auto-mapped-unmapped-text: #a0aec0; /* gray-400 */

  /* Tab Buttons */
  --tab-button-bg-dark: #475569; /* slate-600 */
  --tab-button-hover-bg-dark: #334155; /* slate-700 */
  --tab-button-active-bg-dark: #4f46e5; /* indigo-600 */
  --tab-button-active-text-dark: #f8fafc; /* slate-50 */
  --tab-button-text-dark: #cbd5e1; /* slate-300 */
  
  /* Clickable Elements List */
  --clickable-container-bg: #2d3748; /* gray-800 */
  --clickable-item-border: #4a5568; /* gray-700 */
  --clickable-item-hover-bg: #4a5568; /* gray-700 */
  --selected-item-highlight-bg-dark: #3730a3; /* indigo-900 */
  --selected-item-highlight-border-dark: #4f46e5; /* indigo-600 */

  /* New & Refined Shadows (Dark Mode) */
  --main-container-shadow-dark: 
    0 15px 30px -10px rgba(0, 0, 0, 0.35), 
    0 8px 15px -5px rgba(0, 0, 0, 0.2);
  --card-shadow-dark: 
    0 6px 12px -4px rgba(0, 0, 0, 0.2), 
    0 3px 6px -2px rgba(0, 0, 0, 0.15);
  
  --primary-button-shadow-dark: 
    0 10px 20px -5px rgba(79, 70, 229, 0.4), 
    0 4px 6px -2px rgba(79, 70, 229, 0.2);
  --emerald-button-shadow-dark: 
    0 10px 20px -5px rgba(6, 95, 70, 0.4), 
    0 4px 6px -2px rgba(6, 95, 70, 0.2);
  --secondary-button-shadow-dark: 
    0 8px 15px -4px rgba(74, 85, 104, 0.25), 
    0 3px 5px -1px rgba(74, 85, 104, 0.1);

  --tab-button-active-shadow-dark: 
    0 8px 16px rgba(0,0,0,0.3), 
    0 4px 8px rgba(0,0,0,0.15);

  --drop-area-inner-shadow-dark: inset 0 2px 4px rgba(0, 0, 0, 0.1);

  --header-badge-shadow-dark: 0 2px 4px rgba(0,0,0,0.2);
}

/* Base styles for the body, applied in light mode by default */
html { /* Set default font and background for the entire document */
    box-sizing: border-box;
    background-color: var(--bg-color-light); /* Default background for html */
    color: var(--text-color-light); /* Default text color for html */
    transition: background-color 0.3s ease, color 0.3s ease; /* Smooth transition for theme change */
}
*, *::before, *::after { /* Universal box-sizing reset */
    box-sizing: inherit;
}
body { /* Body specific styles */
    font-family: 'Inter', sans-serif;
    min-width: 380px; /* Wider popup */
    overflow-x: hidden; /* Prevent horizontal scrollbar */
}

/* Explicitly hide the default file input */
#fileInputAutoFill, #fileInputFullAutomation { 
    display: none !important;
}

/* Main Container styling */
.main-container {
    padding: 2rem; /* Generous padding */
    background-color: var(--card-bg-light);
    border-radius: 1rem; /* Rounded corners */
    /* Refined shadow for a softer, more layered look */
    box-shadow: var(--main-container-shadow-light);
    border: 1px solid var(--border-color-light); /* Added a subtle border */
    max-width: 500px; /* Increased max width */
    min-height: 500px; /* Give it some vertical presence */
    position: relative; /* For theme switch positioning */
    transition: background-color 0.3s ease, box-shadow 0.3s ease, border-color 0.3s ease;
}

/* Section and Card Headings */
.section-heading, .card-heading {
    color: var(--header-text-color-light);
    border-color: var(--border-color-light);
    transition: color 0.3s ease, border-color 0.3s ease;
}

/* Card Styling */
.card {
    background-color: var(--card-bg-light);
    padding: 1.5rem; /* Generous padding */
    border: 1px solid var(--border-color-light); /* Consistent subtle border */
    border-radius: 0.75rem;
    /* Refined shadow for cards */
    box-shadow: var(--card-shadow-light);
    margin-bottom: 1.5rem; /* Space between cards */
    transition: background-color 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease;
}

/* Generic Action Button Styling */
.action-button {
    display: flex; /* Flexbox for icon and text alignment */
    align-items: center;
    justify-content: center;
    padding: 0.85rem 1.75rem; /* Slightly increased vertical padding for better feel */
    border-radius: 9999px; /* Fully rounded (pill shape) */
    font-weight: 600;
    transition: background-color 0.3s ease, transform 0.1s ease, box-shadow 0.3s ease, border-color 0.3s ease;
    border: 1px solid transparent; /* Subtle border for precision */
    cursor: pointer;
    font-size: 0.95rem; /* Slightly smaller for compactness */
    line-height: 1.25rem; /* Adjusted line height */
    outline: none; /* Remove default focus outline */
    /* Remove base box-shadow here, specific button classes will apply their own */
    box-shadow: none; 
}
.action-button:hover {
    transform: translateY(-2px); /* Subtle lift */
    /* Box shadow handled by specific button types using their hover colors */
}
.action-button:active {
    transform: translateY(0); /* Press down effect */
    /* Box shadow handled by specific button types */
}
.action-button:focus-visible {
    /* Custom focus ring for accessibility, simpler now */
    box-shadow: 0 0 0 4px rgba(var(--focus-ring-color-rgb), 0.5); 
}
.action-button:disabled { /* Styling for disabled buttons */ 
    opacity: 0.6;
    cursor: not-allowed;
    transform: none; /* Disable lift effect when disabled */
    box-shadow: none;
}


/* Specific button colors (light mode) */
.action-button.primary {
    background-color: var(--primary-button-bg-light);
    color: #fff;
    border-color: var(--primary-button-border-light);
    box-shadow: var(--primary-button-shadow-light); /* Apply defined shadow */
    --focus-ring-color-rgb: 37, 99, 235; /* blue-600 RGB */
}
.action-button.primary:hover:not(:disabled) {
    background-color: var(--primary-button-hover-bg-light);
    box-shadow: 0 12px 24px -8px rgba(37, 99, 235, 0.45), 0 5px 8px -2px rgba(37, 99, 235, 0.25); /* Stronger hover shadow */
}

.action-button.emerald {
    background-color: var(--emerald-button-bg-light);
    color: #fff;
    border-color: var(--emerald-button-border-light);
    box-shadow: var(--emerald-button-shadow-light); /* Apply defined shadow */
    --focus-ring-color-rgb: 5, 150, 105; /* emerald-600 RGB */
}
.action-button.emerald:hover:not(:disabled) {
    background-color: var(--emerald-button-hover-bg-light);
    box-shadow: 0 12px 24px -8px rgba(5, 150, 105, 0.45), 0 5px 8px -2px rgba(5, 150, 105, 0.25);
}

.action-button.secondary {
    background-color: var(--secondary-button-bg-light); /* Use gray for secondary button */
    color: #fff; /* White text for better contrast on gray */
    border-color: var(--secondary-button-border-light);
    box-shadow: var(--secondary-button-shadow-light); /* Lighter shadow */
    --focus-ring-color-rgb: 107, 114, 128; /* gray-500 RGB */
}
.action-button.secondary:hover:not(:disabled) {
    background-color: var(--secondary-button-hover-bg-light);
    box-shadow: 0 12px 20px -8px rgba(107, 114, 128, 0.35), 0 5px 8px -2px rgba(107, 114, 128, 0.15);
}

/* Form Input Styling */
.form-input {
    border: 1px solid var(--input-border-light);
    border-radius: 0.5rem; /* Rounded corners */
    padding: 0.75rem 1rem; /* Slightly more padding */
    width: 100%;
    background-color: var(--card-bg-light); /* Consistent with card background */
    color: var(--text-color-light);
    transition: border-color 0.2s ease, box-shadow 0.2s ease;
    -webkit-appearance: none; /* Remove default browser styling */
    -moz-appearance: none;
    appearance: none;
}
.form-input:focus {
    border-color: var(--input-focus-ring-light);
    outline: none;
    box-shadow: 0 0 0 3px rgba(var(--input-focus-ring-rgb-values-light), 0.3); /* Custom focus ring */
}
.form-input:disabled { /* Styling for disabled inputs */ 
    background-color: #f3f4f6; /* Lighter gray for disabled */
    cursor: not-allowed;
    opacity: 0.7;
}
html.dark .form-input:disabled {
    background-color: #374151; /* Darker gray for disabled in dark mode */
}


/* File Drop Area Styling */
.drop-area {
    border: 2px dashed var(--drop-area-border-light);
    border-radius: 0.75rem;
    padding: 2.5rem; /* More generous padding */
    text-align: center;
    background-color: var(--drop-area-bg-light);
    transition: background-color 0.3s ease, border-color 0.3s ease, color 0.3s ease;
    cursor: pointer;
    display: flex;
    flex-direction: column;
    align-items: center; /* Center content vertically and horizontally */
    justify-content: center; /* Center content vertically and horizontally */
    min-height: 12rem; /* Increased min height */
    box-shadow: var(--drop-area-inner-shadow-light); /* Added inner shadow */
}
.drop-area:hover {
    background-color: var(--drop-area-hover-bg-light);
    border-color: var(--primary-button-bg-light); /* Highlight border on hover */
}
.drop-area p {
    color: var(--drop-area-text-light);
    margin-bottom: 0.75rem; /* Slightly less margin */
    font-size: 1.125rem;
    font-weight: 500;
}
.drop-area:hover p {
    color: var(--drop-area-hover-text-light);
}
.browse-button {
    display: inline-block;
    background-color: var(--primary-button-bg-light);
    color: #fff;
    padding: 0.9rem 2.25rem; /* Adjusted to match action button padding */
    border-radius: 9999px;
    font-size: 1rem; /* Consistent with action buttons */
    font-weight: 600;
    box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
    transition: background-color 0.3s ease, box-shadow 0.3s ease;
    cursor: pointer;
}
.browse-button:hover {
    background-color: var(--primary-button-hover-bg-light);
    box-shadow: 0 6px 10px -2px rgba(0, 0, 0, 0.15), 0 3px 6px -2px rgba(0, 0, 0, 0.08);
}

/* File Status Message Styling */
.file-status {
    padding: 0.875rem 1.25rem;
    border-radius: 0.625rem;
    font-size: 0.9rem; /* Slightly smaller for compactness */
    font-weight: 500;
    line-height: 1.4;
    display: flex;
    align-items: center;
    transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
}
.file-status.message-success {
    background-color: var(--file-status-success-bg-light);
    border: 1px solid var(--file-status-success-border-light);
    color: var(--file-status-success-text-light); /* Text color */
}
.file-status.message-success #fileStatusIconAutoFill,
.file-status.message-success #fileStatusIconFullAutomation { /* Updated IDs */
    color: var(--file-status-success-icon-light);
}
.file-status.message-error {
    background-color: var(--file-status-error-bg-light);
    border: 1px solid var(--file-status-error-border-light);
    color: var(--file-status-error-text-light); /* Text color */
}
.file-status.message-error #fileStatusIconAutoFill,
.file-status.message-error #fileStatusIconFullAutomation { /* Updated IDs */
    color: var(--file-status-error-icon-light);
}
.file-status.message-info {
    background-color: var(--file-status-info-bg-light);
    border: 1px solid var(--file-status-info-border-light); /* Text color */
    color: var(--file-status-info-text-light);
}
.file-status.message-info #fileStatusIconAutoFill,
.file-status.message-info #fileStatusIconFullAutomation { /* Updated IDs */
    color: var(--file-status-info-icon-light);
}

/* Headers List Styling (Badges) */
.headers-list {
    display: flex;
    flex-wrap: wrap;
    gap: 0.75rem; /* Space between headers */
    margin-bottom: 2rem;
}
.headers-list span { /* Badge styling */
    background-color: var(--header-badge-bg-light);
    color: var(--header-badge-text-light);
    padding: 0.6rem 1.25rem;
    border-radius: 9999px;
    font-size: 0.95rem;
    font-weight: 500;
    box-shadow: var(--header-badge-shadow-light); /* Added badge shadow */
    transition: background-color 0.2s ease, box-shadow 0.2s ease;
    display: flex;
    align-items: center;
    cursor: default;
}
.headers-list span.dark { /* Apply dark mode styles when span itself has 'dark' class */
    background-color: var(--header-badge-bg-dark);
    color: var(--header-badge-text-dark);
}
.headers-list span:hover {
    background-color: var(--header-badge-hover-bg-light);
}
.headers-list span.dark:hover { /* Hover for dark mode badge */
    background-color: var(--header-badge-hover-bg-dark);
}

/* Checkbox/Radio Labels (Custom appearance) */
.checkbox-label, .radio-label {
    display: flex;
    align-items: center;
    cursor: pointer;
    color: var(--text-color-light);
    user-select: none; /* Prevent text selection */
}
.checkbox-label input[type="checkbox"], .radio-label input[type="radio"] {
    height: 1.125rem;
    width: 1.125rem;
    border: 2px solid var(--input-border-light); /* Thicker border */
    border-radius: 0.25rem; /* For checkboxes */
    background-color: var(--card-bg-light);
    transition: background-color 0.2s ease, border-color 0.2s ease, transform 0.1s ease;
    -webkit-appearance: none;
    -moz-appearance: none;
    appearance: none;
    flex-shrink: 0;
    margin-right: 0.5rem;
    position: relative; /* For custom checkmark/dot */
    cursor: pointer;
}
.checkbox-label input[type="checkbox"]:checked {
    background-color: var(--primary-button-bg-light);
    border-color: var(--primary-button-bg-light);
    position: relative;
}
.checkbox-label input[type="checkbox"]:checked::after {
    content: '\2713'; /* Checkmark unicode character */
    font-size: 0.75rem;
    color: white;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-weight: 700; /* Make checkmark bold */
}
.radio-label input[type="radio"]:checked {
    background-color: var(--primary-button-bg-light);
    border-color: var(--primary-button-bg-light);
}
.radio-label input[type="radio"] {
    border-radius: 50%; /* Make radio buttons round */
}
.radio-label input[type="radio"]:checked::after {
    content: '';
    width: 0.5rem;
    height: 0.5rem;
    background-color: white;
    border-radius: 50%;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) scale(1); /* Initial scale */
    transition: transform 0.2s ease; /* Smooth transition for scale */
}
.checkbox-label input[type="checkbox"]:focus, .radio-label input[type="radio"]:focus {
    outline: none;
    box-shadow: 0 0 0 3px rgba(var(--input-focus-ring-rgb-values-light), 0.3);
}
.checkbox-label input[type="checkbox"]:active, .radio-label input[type="radio"]:active {
    transform: scale(0.95); /* Subtle press effect */
}

/* General Message Boxes (info, success, error) */
.message-box {
    padding: 0.875rem 1rem;
    border-radius: 0.5rem;
    font-size: 0.9rem;
    font-weight: 500;
    line-height: 1.35;
    display: flex;
    align-items: center;
    margin-top: 1rem;
    transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
}
.message-box i {
    margin-right: 0.75rem;
    font-size: 1.25rem; /* Larger icon */
}
.message-success {
    background-color: #d1fae5; /* green-100 */
    border: 1px solid #34d399; /* green-400 */
    color: #065f46; /* green-700 */
}
.message-error {
    background-color: #fee2e2; /* red-100 */
    border: 1px solid #f87171; /* red-400 */
    color: #991b1b; /* red-700 */
}
.message-info {
    background-color: #e0f2fe; /* light blue-100 */
    border: 1px solid #60a5fa; /* blue-400 */
    color: #1e40af; /* blue-700 */
}

/* Loading Spinner Animation */
.loading-spinner {
    border: 4px solid rgba(0, 0, 0, 0.1);
    border-left-color: var(--primary-button-bg-light); /* Uses primary color for spin */
    border-radius: 50%;
    width: 24px;
    height: 24px;
    animation: spin 1s linear infinite;
    display: inline-block;
    vertical-align: middle;
    margin-left: 0.5rem;
}
@keyframes spin {
    to { transform: rotate(360deg); }
}

/* Badges for Auto-Mapped Fields */
.auto-mapped-badge {
    display: inline-block;
    font-size: 0.7rem;
    font-weight: 600;
    padding: 0.2rem 0.6rem;
    border-radius: 9999px;
    margin-left: 0.75rem;
    white-space: nowrap;
    transition: background-color 0.3s ease, color 0.3s ease;
}
.auto-mapped-badge.learned {
    background-color: var(--auto-mapped-learned-bg);
    color: var(--auto-mapped-learned-text);
}
.auto-mapped-badge.fuzzy {
    background-color: var(--auto-mapped-fuzzy-bg);
    color: var(--auto-mapped-fuzzy-text);
}
.auto-mapped-badge.unmapped {
    background-color: var(--auto-mapped-unmapped-bg);
    color: var(--auto-mapped-unmapped-text);
}
.auto-mapped-badge.dark { /* Dark mode for badges */
  background-color: var(--auto-mapped-learned-bg); /* Use dark variable for bg */
  color: var(--auto-mapped-learned-text); /* Use dark variable for text */
}
.auto-mapped-badge.fuzzy.dark {
  background-color: var(--auto-mapped-fuzzy-bg);
  color: var(--auto-mapped-fuzzy-text);
}
.auto-mapped-badge.unmapped.dark {
  background-color: var(--auto-mapped-unmapped-bg);
  color: var(--auto-mapped-unmapped-text);
}

/* Tab Styling */
.tab-buttons {
    display: flex;
    gap: 0.75rem; /* Increased gap */
    margin-bottom: 1.5rem;
    padding: 0.375rem;
    background-color: var(--tab-button-bg);
    border-radius: 0.75rem;
    box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.05);
    transition: background-color 0.3s ease;
}
.tab-button {
    flex-grow: 1;
    padding: 0.625rem 1rem;
    border-radius: 0.75rem; /* Slightly more rounded */
    text-align: center;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.3s ease-in-out;
    background-color: transparent;
    color: var(--tab-button-text);
    border: none;
}
.tab-button:hover {
    background-color: var(--tab-button-hover-bg);
}
.tab-button.active {
    background-color: var(--tab-button-active-bg);
    color: var(--tab-button-active-text);
    box-shadow: var(--tab-button-active-shadow-light);
    transform: translateY(-1px); /* Slight lift for active tab */
    font-weight: 600;
}
.tab-button i {
    margin-right: 0.5rem;
}
.tab-content {
    transition: opacity 0.3s ease-in-out;
}
.tab-content.hidden {
    display: none;
}

/* Field Mapping Group Item */
.field-mapping-group-item {
    padding: 1rem; /* Slightly less padding than main card */
    margin-bottom: 1rem; /* Space between mapping groups */
}
.field-mapping-group-item .group-mapper {
    border: 1px solid var(--input-border-light);
    border-radius: 0.5rem;
    padding: 0.5rem 0.75rem;
    background-color: var(--card-bg-light);
    color: var(--text-color-light);
}

/* Specific styles for Auto Click section */
#clickableButtonsContainer, #clickControlSection .scrollable-list { /* Generic class for scrollable lists */
    max-height: 15rem;
    overflow-y: auto;
    border: 1px solid var(--list-item-border-light);
    border-radius: 0.625rem; /* More consistent border radius */
    padding: 0.5rem;
    margin-bottom: 1.5rem;
    transition: background-color 0.3s ease, border-color 0.3s ease;
}
#clickableButtonsContainer > div {
    display: flex;
    align-items: center;
    padding: 0.75rem; /* More padding for list items */
    border-bottom: 1px solid var(--clickable-item-border);
    border-radius: 0.375rem;
    margin-bottom: 0.25rem;
    transition: background-color 0.2s ease, border-color 0.2s ease;
}
#clickableButtonsContainer > div:last-child {
    border-bottom: none;
    margin-bottom: 0;
}
#clickableButtonsContainer > div:hover:not(.selected-button-highlight) { /* Don't change hover color for selected item */
    background-color: var(--list-item-hover-bg-light);
}
#clickableButtonsContainer label { 
    margin-left: 0.5rem;
    font-size: 0.95rem;
    color: var(--text-color-light);
    flex-grow: 1;
}
#clickableButtonsContainer input[type="radio"] {
    margin-right: 0.5rem;
    flex-shrink: 0;
}
#clickControlSection label {
    display: block;
    font-size: 0.9rem;
    font-weight: 500;
    color: var(--text-color-light);
    margin-bottom: 0.75rem;
} /* Specific to clickControlSection's labels */
/* Highlight for selected clickable button */
.selected-button-highlight {
    background-color: var(--selected-item-highlight-bg-light);
    border-color: var(--selected-button-highlight-border);
    font-weight: 600;
}


/* Theme Toggle Switch */
.theme-switch {
  position: absolute;
  top: 1rem;
  right: 1rem;
  z-index: 10;
}
.theme-switch input {
  display: none; /* Hide default checkbox */
}
.slider {
  width: 44px;
  height: 24px;
  background: var(--border-color-light); /* Light mode slider background */
  border-radius: 24px;
  cursor: pointer;
  position: relative;
  transition: background 0.3s ease;
  display: block;
}
.slider::before {
  content: "";
  position: absolute;
  top: 2px;
  left: 2px;
  width: 20px;
  height: 20px;
  background: var(--text-color-light); /* Light mode knob color */
  border-radius: 50%;
  transition: transform 0.3s ease, background 0.3s ease;
}
/* When checked (dark mode active) */
input:checked + .slider {
    background: var(--primary-button-bg-light); /* Primary color for slider background in light mode */
}
input:checked + .slider::before {
  transform: translateX(20px);
  background: white; /* White knob when checked */
}

/* Dark Mode Overrides (apply when body has 'dark' class) */
html.dark { /* Apply dark mode styles to html element */
    background-color: var(--bg-color-dark);
    color: var(--text-color-dark);
} 
.main-container.dark {
    background-color: var(--card-bg-dark);
    border-color: var(--border-color-dark);
    box-shadow: var(--main-container-shadow-dark);
}
.section-heading.dark, .card-heading.dark {
    color: var(--header-text-color-dark);
    border-color: var(--border-color-dark);
}
.card.dark {
    background-color: var(--card-bg-dark);
    border-color: var(--border-color-dark);
    box-shadow: var(--card-shadow-dark); /* Refined dark mode shadow for cards */
}
.action-button.primary.dark {
    background-color: var(--primary-button-bg-dark);
    border-color: var(--primary-button-border-dark);
    box-shadow: var(--primary-button-shadow-dark);
    --focus-ring-color-rgb: 79, 70, 229; /* indigo-500 RGB */
}
.action-button.primary.dark:hover:not(:disabled) {
    background-color: var(--primary-button-hover-bg-dark);
    box-shadow: 0 12px 24px -8px rgba(79, 70, 229, 0.45), 0 5px 8px -2px rgba(79, 70, 229, 0.25);
}
.action-button.emerald.dark {
    background-color: var(--emerald-button-bg-dark);
    border-color: var(--emerald-button-border-dark);
    box-shadow: var(--emerald-button-shadow-dark);
    --focus-ring-color-rgb: 6, 95, 70; /* emerald-800 RGB */
}
.action-button.emerald.dark:hover:not(:disabled) {
    background-color: var(--emerald-button-hover-bg-dark);
    box-shadow: 0 12px 24px -8px rgba(6, 95, 70, 0.45), 0 5px 8px -2px rgba(6, 95, 70, 0.25);
}
.action-button.secondary.dark {
    background-color: var(--secondary-button-bg-dark);
    color: var(--text-color-dark);
    border-color: var(--secondary-button-border-dark);
    box-shadow: var(--secondary-button-shadow-dark);
    --focus-ring-color-rgb: 74, 85, 104; /* gray-700 RGB */
}
.action-button.secondary.dark:hover:not(:disabled) { /* More distinct hover for dark secondary */
    background-color: var(--secondary-button-hover-bg-dark);
    box-shadow: 0 12px 20px -8px rgba(74, 85, 104, 0.35), 0 5px 8px -2px rgba(74, 85, 104, 0.15);
}
.form-input.dark {
    border-color: var(--input-border-dark);
    background-color: var(--card-bg-dark);
    color: var(--text-color-dark);
}
.form-input.dark:focus {
    border-color: var(--input-focus-ring-dark);
    box-shadow: 0 0 0 3px rgba(var(--input-focus-ring-rgb-values-dark), 0.3);
}
.drop-area.dark {
    border-color: var(--drop-area-border-dark);
    background-color: var(--drop-area-bg-dark);
    box-shadow: var(--drop-area-inner-shadow-dark);
}
.drop-area.dark:hover {
    background-color: var(--drop-area-hover-bg-dark);
    border-color: var(--primary-button-bg-dark);
}
.drop-area.dark p {
    color: var(--drop-area-text-dark); /* Apply dark text color */
}
.drop-area.dark:hover p {
    color: var(--drop-area-hover-text-dark); /* Apply dark hover text color */
}
.browse-button.dark { /* Dark mode for browse button */
    background-color: var(--primary-button-bg-dark);
}
.browse-button.dark:hover {
    background-color: var(--primary-button-hover-bg-dark);
}
.file-status.message-success.dark {
  background-color: var(--file-status-success-bg-dark);
  border-color: var(--file-status-success-border-dark);
  color: var(--file-status-success-text-dark);
}
.file-status.message-success.dark #fileStatusIconAutoFill,
.file-status.message-success.dark #fileStatusIconFullAutomation { /* Updated IDs */
    color: var(--file-status-success-icon-dark); /* Apply dark icon color */
}
.file-status.message-error.dark {
  background-color: var(--file-status-error-bg-dark);
  border-color: var(--file-status-error-border-dark);
  color: var(--file-status-error-text-dark);
}
.file-status.message-error.dark #fileStatusIconAutoFill,
.file-status.message-error.dark #fileStatusIconFullAutomation { /* Updated IDs */
    color: var(--file-status-error-icon-dark); /* Apply dark icon color */
}
.file-status.message-info.dark {
  background-color: var(--file-status-info-bg-dark);
  border-color: var(--file-status-info-border-dark);
  color: var(--file-status-info-text-dark);
}
.file-status.message-info.dark #fileStatusIconAutoFill,
.file-status.message-info.dark #fileStatusIconFullAutomation { /* Updated IDs */
    color: var(--file-status-info-icon-dark); /* Apply dark icon color */
}
.headers-list.dark span {
    background-color: var(--header-badge-bg-dark);
    color: var(--header-badge-text-dark);
    box-shadow: var(--header-badge-shadow-dark);
}
.headers-list.dark span:hover {
    background-color: var(--header-badge-hover-bg-dark);
}
.checkbox-label.dark, .radio-label.dark {
    color: var(--text-color-dark);
}
.checkbox-label.dark input[type="checkbox"], .radio-label.dark input[type="radio"] {
    border-color: var(--input-border-dark);
    background-color: var(--card-bg-dark);
}
.checkbox-label.dark input[type="checkbox"]:checked, .radio-label.dark input[type="radio"]:checked { /* Checkbox/Radio checked in dark mode */
    background-color: var(--primary-button-bg-dark);
    border-color: var(--primary-button-bg-dark);
}
.checkbox-label.dark input[type="checkbox"]:focus, .radio-label.dark input[type="radio"]:focus {
    box-shadow: 0 0 0 3px rgba(var(--input-focus-ring-rgb-values-dark), 0.3);
}
/* Dark mode for generic message boxes */
.message-success.dark {
  background-color: #065f46; /* green-900 */
  border-left-color: #10b981; /* green-600 */
  color: #d1fae5; /* green-100 */
}
.message-error.dark {
  background-color: #7f1d1d; /* red-900 */
  border-left-color: #dc2626; /* red-600 */
  color: #fee2e2; /* red-100 */
}
.message-info.dark {
  background-color: #1e3a8a; /* blue-900 */
  border-left-color: #0284c7; /* light-blue-700 */
  color: #e0f2fe; /* blue-100 */
}
.auto-mapped-badge.learned.dark {
  background-color: var(--auto-mapped-learned-bg);
  color: var(--auto-mapped-learned-text);
}
.auto-mapped-badge.fuzzy.dark {
  background-color: var(--auto-mapped-fuzzy-bg);
  color: var(--auto-mapped-fuzzy-text);
}
.auto-mapped-badge.unmapped.dark {
  background-color: var(--auto-mapped-unmapped-bg);
  color: var(--auto-mapped-unmapped-text);
}
.tab-buttons.dark {
    background-color: var(--tab-button-bg-dark);
}
.tab-button.dark {
    color: var(--tab-button-text-dark);
}
.tab-button.dark:hover {
    background-color: var(--tab-button-hover-bg-dark);
}
.tab-button.active.dark {
    background-color: var(--tab-button-active-bg-dark);
    color: var(--tab-button-active-text-dark);
    box-shadow: var(--tab-button-active-shadow-dark);
}
#clickableButtonsContainer.dark, #clickControlSection .scrollable-list.dark { /* Generic list dark mode */
    border-color: var(--list-item-border-light);
    background-color: var(--clickable-container-bg); /* This variable is already dark-mode specific */
}
#clickableButtonsContainer.dark > div, #clickControlSection .scrollable-list.dark > div {
    border-color: var(--list-item-border-light);
}
#clickableButtonsContainer.dark > div:hover:not(.selected-button-highlight), #clickControlSection .scrollable-list.dark > div:hover:not(.selected-button-highlight) {
    background-color: var(--clickable-item-hover-bg); /* This variable is already dark-mode specific */
}
#clickableButtonsContainer.dark label, #clickControlSection .scrollable-list.dark label {
    color: var(--text-color-dark);
}
#clickControlSection.dark { /* Card for click control section in dark mode */
    border-color: var(--clickable-item-border);
    background-color: var(--clickable-container-bg);
}
#clickControlSection.dark label {
    color: var(--text-color-dark);
}
.selected-button-highlight.dark {
    background-color: var(--selected-item-highlight-bg-dark); /* Now uses dark mode specific var */
    border-color: var(--selected-item-highlight-border-dark);
    color: var(--text-color-dark); /* Ensure text color is good */
}
/* Dark mode for theme switch slider */
.theme-switch input:checked + .slider.dark {
    background: var(--primary-button-bg-dark);
}
.theme-switch input:checked + .slider.dark::before {
  background: white;
}
.slider.dark {
    background: var(--border-color-dark);
}
.slider.dark::before {
  background: var(--text-color-dark);
}


/* Responsive adjustments for popup sizes */
@media (max-width: 520px) { /* Adjusted breakpoint */
  .main-container {
    padding: 1.5rem; /* Slightly reduced padding */
  }
  .section-heading, .card-heading {
    font-size: 1rem;
    margin-bottom: 0.75rem;
  }
  .action-button {
    padding: 0.8rem 1.6rem; /* Adjusted for smaller screens */
    font-size: 0.9rem;
  }
  .browse-button {
    padding: 0.8rem 1.6rem;
    font-size: 1rem;
  }
  .drop-area {
    padding: 1.5rem;
    min-height: 8rem;
  }
  .drop-area p {
    font-size: 1rem;
  }
  .file-status, .message-box { /* Apply to generic messages too */
    font-size: 0.85rem;
    padding: 0.75rem 1rem;
  }
  .headers-list span {
    padding: 0.5rem 0.9rem;
    font-size: 0.8rem;
  }
  .tab-button {
    padding: 0.5rem 0.75rem;
    font-size: 0.9rem;
  }
  .theme-switch {
    top: 0.75rem;
    right: 0.75rem;
  }
}
--- END FILE: popup.css ---

--- START FILE: popup.html ---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spreadsheet Data Filler</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Inter font -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <!-- Fuse.js CDN for fuzzy matching -->
    <script src="https://cdn.jsdelivr.net/npm/fuse.js/dist/fuse.min.js"></script>
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <!-- Custom Stylesheet -->
    <link rel="stylesheet" href="popup.css"> 
</head>
<body class="bg-gray-50 dark:bg-gray-900 flex flex-col items-center justify-center min-h-screen p-4 transition-colors duration-300 antialiased">
    <!-- Main Container with responsive sizing and shadows -->
    <div class="main-container bg-white dark:bg-gray-800 rounded-xl shadow-2xl p-6 md:p-8 max-w-lg w-full border border-gray-200 dark:border-gray-700 relative transition-colors duration-300">
        <h1 class="text-2xl md:text-3xl font-bold text-gray-800 dark:text-gray-100 text-center mb-6 pb-2 border-b border-gray-200 dark:border-gray-700">Extension Features</h1>

        <!-- Dark Mode Toggle Switch -->
        <label class="theme-switch absolute top-4 right-4 md:top-6 md:right-6">
          <input type="checkbox" id="themeToggle">
          <span class="slider"></span>
        </label>

        <!-- Tab Buttons for switching features -->
        <div class="tab-buttons">
            <button id="autoFillTab" class="tab-button active">
                <i class="fas fa-file-excel mr-2"></i>Auto Fill
            </button>
            <button id="autoClickTab" class="tab-button">
                <i class="fas fa-mouse-pointer mr-2"></i>Auto Click
            </button>
            <button id="fullAutomationTab" class="tab-button">
                <i class="fas fa-robot mr-2"></i>Full Automation
            </button>
        </div>

        <!-- Auto Fill Section: For uploading spreadsheets and filling forms -->
        <section id="autoFillSection" class="tab-content">
            <h2 class="section-heading text-xl md:text-2xl font-bold text-gray-800 dark:text-gray-100 mb-4 pb-2 border-b border-gray-200 dark:border-gray-700"><i class="fas fa-magic mr-2 text-blue-500"></i>Auto Fill Data</h2>
            
            <!-- Step 1: Upload File Card -->
            <div class="card mb-6">
                <h3 class="card-heading text-md md:text-lg font-semibold text-gray-700 dark:text-gray-200 mb-3"><i class="fas fa-upload mr-2 text-blue-500"></i>1. Upload File</h3>
                <p class="text-gray-600 dark:text-gray-400 text-sm mb-4">Supported: <span class="font-medium text-gray-700 dark:text-gray-300">.XLS, .XLSX, .ODS, .CSV, .XLSM, .XLSB.</span></p>
                
                <div class="drop-area" id="drop-area-autofill">
                    <i class="fas fa-file-upload text-4xl text-blue-500 dark:text-blue-400 mb-3"></i>
                    <input type="file" id="fileInputAutoFill" class="hidden" accept=".xls,.xlsx,.ods,.csv,.xlsm,.xlsb" />
                    <p id="fileNameDisplayAutoFill" class="text-gray-500 dark:text-gray-400 mb-1 group-hover:text-blue-700 dark:group-hover:text-blue-300 transition duration-300 ease-in-out">
                        Drag & Drop your file here, or
                    </p>
                    <!-- New element for row count -->
                    <p id="rowCountDisplayAutoFill" class="text-gray-500 dark:text-gray-400 text-sm mb-4 hidden"></p>
                    <label for="fileInputAutoFill" class="browse-button">
                        Browse File
                    </label>
                </div>
                
                <!-- File status message area -->
                <div id="fileStatusMessageAutoFill" class="file-status mt-4 hidden">
                    <i id="fileStatusIconAutoFill" class="text-xl mr-3"></i>
                    <span id="fileMessageAutoFill" class="text-lg font-medium"></span>
                </div>
            </div>

            <!-- Step 2: Data Display & Field Mapping Card -->
            <div id="dataDisplaySectionAutoFill" class="card hidden">
                <h3 class="card-heading text-md md:text-lg font-semibold text-gray-700 dark:text-gray-200 mb-3"><i class="fas fa-map-marker-alt mr-2 text-blue-500"></i>2. Map Fields</h3>

                <div class="mb-4">
                    <h4 class="text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">File Headers:</h4>
                    <div id="headersDisplayAutoFill" class="headers-list">
                        <!-- Spreadsheet headers will be displayed here dynamically -->
                    </div>
                </div>

                <!-- Scan fields button -->
                <button id="scanFieldsButtonAutoFill" class="action-button emerald w-full mb-4">
                    <i class="fas fa-sync-alt mr-2"></i>Scan Current Tab for Fields
                </button>
                <!-- Message area for scan feedback -->
                <div id="scanMessageAutoFill" class="message-box mt-3 hidden"></div>

                <!-- Field Mapping Section (visible after scan) -->
                <div id="fieldMappingSectionAutoFill" class="mt-4 hidden">
                    <h4 class="text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Available Form Field Groups:</h4>
                    <div id="mappingContainerAutoFill">
                        <!-- Dynamic mapping dropdowns for each grouped field -->
                    </div>
                    <div class="flex items-center mt-4">
                        <label class="checkbox-label mr-3 text-sm">
                            <input type="checkbox" id="fillEmptyOnlyCheckboxAutoFill" class="mr-2">
                            Fill only empty fields
                        </label>
                    </div>

                    <!-- Action buttons for testing and previewing -->
                    <div class="flex flex-col space-y-2 mt-4">
                        <button id="testFillButtonAutoFill" class="action-button secondary w-full">
                            <i class="fas fa-vial mr-2"></i>Test Fill First Row
                        </button>
                        <div id="testFillMessageAutoFill" class="message-box mt-3 hidden"></div>
                        <button id="previewValuesButtonAutoFill" class="action-button secondary w-full">
                            <i class="fas fa-eye mr-2"></i>Preview Mapped Values
                        </button>
                        <div id="previewValuesMessageAutoFill" class="message-box mt-3 hidden"></div>
                    </div>
                </div>
                
                <!-- Main fill data buttons -->
                <div class="flex flex-col space-y-3 mt-6">
                    <button id="fillDataButtonAutoFill" class="action-button primary w-full">
                        <i class="fas fa-paper-plane mr-2"></i>Fill Data
                    </button>
                </div>
                
                <!-- Message area for fill data feedback -->
                <div id="fillDataMessageAutoFill" class="message-box mt-3 hidden"></div>
            </div>
        </section>

        <!-- Auto Click Section: For automating button clicks -->
        <section id="autoClickSection" class="tab-content hidden">
            <h2 class="section-heading text-xl md:text-2xl font-bold text-gray-800 dark:text-gray-100 mb-4 pb-2 border-b border-gray-200 dark:border-gray-700"><i class="fas fa-mouse-pointer mr-2 text-indigo-500"></i>Auto Click Buttons</h2>
            <!-- Message area for auto click feedback -->
            <div id="autoClickMessage" class="message-box mb-4 hidden"></div>
            
            <!-- Step 1: Scan for Clickable Elements Card -->
            <div class="card mb-6">
                <h3 class="card-heading text-md md:text-lg font-semibold text-gray-700 dark:text-gray-200 mb-3"><i class="fas fa-search mr-2 text-indigo-500"></i>1. Scan for Clickable Elements</h3>
                <p class="text-gray-600 dark:text-gray-400 text-sm mb-3">Find buttons and other clickable elements on the current page.</p>
                <button id="scanButtons" class="action-button secondary w-full">
                    <i class="fas fa-sync-alt mr-2"></i>Scan for Clickable Buttons
                </button>
            </div>
            
            <!-- Step 2: Select a Button Card (visible after scan) -->
            <div id="selectButtonCard" class="card hidden mb-6">
                <h3 class="card-heading text-md md:text-lg font-semibold text-gray-700 dark:text-gray-200 mb-3"><i class="fas fa-hand-pointer mr-2 text-indigo-500"></i>2. Select a Button</h3>
                <div id="clickableButtonsContainer" class="scrollable-list bg-gray-50 dark:bg-gray-700 p-2 mb-4">
                    <!-- Clickable buttons will be listed here dynamically as radio buttons -->
                    <p class="text-gray-500 dark:text-gray-400 text-sm p-2">No buttons found yet. Click 'Scan' above.</p>
                </div>
            </div>

            <!-- Step 3: Choose Number of Clicks & Execute Card (visible after scan) -->
            <div id="clickControlSection" class="card hidden">
                <h3 class="card-heading text-md md:text-lg font-semibold text-gray-700 dark:text-gray-200 mb-3"><i class="fas fa-play-circle mr-2 text-indigo-500"></i>3. Choose Number of Clicks & Execute</h3>
                <label for="clickCount" class="text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 block">Number of clicks (per spreadsheet row, or total for single click):</label>
                <input type="number" id="clickCount" value="1" min="1" class="mb-4 form-input" />
                <button id="startClicking" class="action-button primary w-full">
                    <i class="fas fa-bullseye mr-2"></i>Start Clicking
                </button>
            </div>
        </section>

        <!-- Full Automation Section: Combined functionality -->
        <section id="fullAutomationSection" class="tab-content hidden">
            <h2 class="section-heading text-xl md:text-2xl font-bold text-gray-800 dark:text-gray-100 mb-4 pb-2 border-b border-gray-200 dark:border-gray-700"><i class="fas fa-robot mr-2 text-emerald-500"></i>Full Automation</h2>
            
            <!-- Message area for full automation feedback -->
            <div id="fullAutomationMessage" class="message-box mb-4 hidden"></div>

            <!-- Step 1: Upload File Card (reusing structure, but separate elements) -->
            <div class="card mb-6">
                <h3 class="card-heading text-md md:text-lg font-semibold text-gray-700 dark:text-gray-200 mb-3"><i class="fas fa-upload mr-2 text-emerald-500"></i>1. Upload File</h3>
                <p class="text-gray-600 dark:text-gray-400 text-sm mb-4">Supported: <span class="font-medium text-gray-700 dark:text-gray-300">.XLS, .XLSX, .ODS, .CSV, .XLSM, .XLSB.</span></p>
                
                <div class="drop-area" id="drop-area-fullautomation">
                    <i class="fas fa-file-upload text-4xl text-emerald-500 dark:text-emerald-400 mb-3"></i>
                    <input type="file" id="fileInputFullAutomation" class="hidden" accept=".xls,.xlsx,.ods,.csv,.xlsm,.xlsb" />
                    <p id="fileNameDisplayFullAutomation" class="text-gray-500 dark:text-gray-400 mb-1 group-hover:text-blue-700 dark:group-hover:text-blue-300 transition duration-300 ease-in-out">
                        Drag & Drop your file here, or
                    </p>
                    <p id="rowCountDisplayFullAutomation" class="text-gray-500 dark:text-gray-400 text-sm mb-4 hidden"></p>
                    <label for="fileInputFullAutomation" class="browse-button">
                        Browse File
                    </label>
                </div>
                
                <div id="fileStatusMessageFullAutomation" class="file-status mt-4 hidden">
                    <i id="fileStatusIconFullAutomation" class="text-xl mr-3"></i>
                    <span id="fileMessageFullAutomation" class="text-lg font-medium"></span>
                </div>
            </div>

            <!-- Step 2: Data Display & Field Mapping Card (reusing structure) -->
            <div id="dataDisplaySectionFullAutomation" class="card hidden">
                <h3 class="card-heading text-md md:text-lg font-semibold text-gray-700 dark:text-gray-200 mb-3"><i class="fas fa-map-marker-alt mr-2 text-emerald-500"></i>2. Map Fields</h3>

                <div class="mb-4">
                    <h4 class="text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">File Headers:</h4>
                    <div id="headersDisplayFullAutomation" class="headers-list">
                        <!-- Spreadsheet headers will be displayed here dynamically -->
                    </div>
                </div>

                <!-- Scan fields button -->
                <button id="scanFieldsButtonFullAutomation" class="action-button secondary w-full mb-4">
                    <i class="fas fa-sync-alt mr-2"></i>Scan Current Tab for Fields
                </button>
                <div id="scanMessageFullAutomation" class="message-box mt-3 hidden"></div>

                <!-- Field Mapping Section (visible after scan) -->
                <div id="fieldMappingSectionFullAutomation" class="mt-4 hidden">
                    <h4 class="text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Available Form Field Groups:</h4>
                    <div id="mappingContainerFullAutomation">
                        <!-- Dynamic mapping dropdowns for each grouped field -->
                    </div>
                    <div class="flex items-center mt-4">
                        <label class="checkbox-label mr-3 text-sm">
                            <input type="checkbox" id="fillEmptyOnlyCheckboxFullAutomation" class="mr-2">
                            Fill only empty fields
                        </label>
                    </div>
                </div>
            </div>

            <!-- Step 3: Start Full Automation Button -->
            <div class="flex flex-col space-y-3 mt-6">
                <button id="startFullAutomationButton" class="action-button primary w-full">
                    <i class="fas fa-play mr-2"></i>Start Full Automation
                </button>
            </div>
        </section>
    </div>

    <!-- SheetJS Library - NOW LOCAL -->
    <script src="xlsx.full.min.js"></script>
    <script src="popup.js"></script>
    <script>
        // Global error handler for better debugging in the popup context
        window.onerror = function (msg, url, lineNo, columnNo, error) {
            console.error('Global Error (popup.html):', { msg, url, lineNo, columnNo, error });
            const errorMessageElement = document.getElementById('fileStatusMessageAutoFill') || document.getElementById('scanMessageAutoFill') || document.getElementById('fillDataMessageAutoFill') || document.getElementById('autoClickMessage') || document.getElementById('fullAutomationMessage');
            if (errorMessageElement) {
                // Display a user-friendly error message, avoiding specific internal details
                errorMessageElement.innerHTML = `<i class="fas fa-exclamation-circle text-red-500 text-xl mr-3"></i><span class="text-lg font-medium">An unexpected error occurred. Please try again. If the issue persists, check the browser's console for more details.</span>`;
                errorMessageElement.className = 'file-status message-error';
                errorMessageElement.classList.remove('hidden');
                
                // Set a timeout to hide the error message after a few seconds
                setTimeout(() => {
                    errorMessageElement.classList.add('hidden');
                    errorMessageElement.innerHTML = '';
                }, 7000); // Increased visibility duration for critical errors
            }
        };
    </script>
</body>
</html>
--- END FILE: popup.html ---

--- START FILE: popup.js ---

// Global variables to store parsed data and headers
let workbook = null;
let sheetData = []; // Stores all data from the first sheet (including headers as first row)
let headers = [];   // Stores the first row (headers)
let availableFormFields = []; // Stores fields found on the active tab
let groupedFormFields = {}; // Stores fields grouped by their 'surroundingText' or derived name
let learnedMappings = {}; // Stores user's preferred mappings for schema learning
let actualNonEmptyDataRowsCount = 0; // NEW: Stores the count of actual data rows, excluding empty ones

// Helper to check if content script is already loaded and responsive
async function isContentScriptLoaded(tabId) {
    try {
        // Send a dummy message to content.js and expect a 'pong' response
        const response = await chrome.tabs.sendMessage(tabId, { action: "ping" });
        return response && response.status === "pong";
    } catch (e) {
        // If an error occurs (e.g., recipient disconnected, script not injected),
        // it means the content script is not loaded or not responding.
        console.warn("Content script not loaded or not responding:", e.message);
        return false;
    }
}


// DOM Elements - Tabs
const autoFillTab = document.getElementById("autoFillTab");
const autoClickTab = document.getElementById("autoClickTab");
const fullAutomationTab = document.getElementById("fullAutomationTab"); // New Tab
const autoFillSection = document.getElementById("autoFillSection");
const autoClickSection = document.getElementById("autoClickSection");
const fullAutomationSection = document.getElementById("fullAutomationSection"); // New Section

// DOM Elements - Auto Fill Section (prefixed with AutoFill)
const fileInputAutoFill = document.getElementById('fileInputAutoFill');
const dropAreaAutoFill = document.getElementById('drop-area-autofill');
const fileNameDisplayAutoFill = document.getElementById('fileNameDisplayAutoFill');
const rowCountDisplayAutoFill = document.getElementById('rowCountDisplayAutoFill');
const fileStatusMessageAutoFill = document.getElementById('fileStatusMessageAutoFill');
const fileMessageAutoFill = document.getElementById('fileMessageAutoFill');
const fileStatusIconAutoFill = document.getElementById('fileStatusIconAutoFill');
const dataDisplaySectionAutoFill = document.getElementById('dataDisplaySectionAutoFill');
const headersDisplayAutoFill = document.getElementById('headersDisplayAutoFill');
const scanFieldsButtonAutoFill = document.getElementById('scanFieldsButtonAutoFill');
const scanMessageAutoFill = document.getElementById('scanMessageAutoFill');
const fieldMappingSectionAutoFill = document.getElementById('fieldMappingSectionAutoFill');
const mappingContainerAutoFill = document.getElementById('mappingContainerAutoFill');
const fillDataButtonAutoFill = document.getElementById('fillDataButtonAutoFill');
const fillDataMessageAutoFill = document.getElementById('fillDataMessageAutoFill');
const fillEmptyOnlyCheckboxAutoFill = document.getElementById('fillEmptyOnlyCheckboxAutoFill');
const testFillButtonAutoFill = document.getElementById('testFillButtonAutoFill');
const previewValuesButtonAutoFill = document.getElementById('previewValuesButtonAutoFill');
const testFillMessageAutoFill = document.getElementById('testFillMessageAutoFill');
const previewValuesMessageAutoFill = document.getElementById('previewValuesMessageAutoFill');

// DOM Elements - Auto Click Section (existing)
const scanButtons = document.getElementById("scanButtons");
const clickableButtonsContainer = document.getElementById("clickableButtonsContainer");
const clickCountInput = document.getElementById("clickCount");
const startClickingButton = document.getElementById("startClicking");
const autoClickMessage = document.getElementById("autoClickMessage");
const selectButtonCard = document.getElementById("selectButtonCard");
const clickControlSection = document.getElementById("clickControlSection");

// DOM Elements - Full Automation Section (new)
const fileInputFullAutomation = document.getElementById('fileInputFullAutomation');
const dropAreaFullAutomation = document.getElementById('drop-area-fullautomation');
const fileNameDisplayFullAutomation = document.getElementById('fileNameDisplayFullAutomation');
const rowCountDisplayFullAutomation = document.getElementById('rowCountDisplayFullAutomation');
const fileStatusMessageFullAutomation = document.getElementById('fileStatusMessageFullAutomation');
const fileMessageFullAutomation = document.getElementById('fileMessageFullAutomation');
const fileStatusIconFullAutomation = document.getElementById('fileStatusIconFullAutomation');
const dataDisplaySectionFullAutomation = document.getElementById('dataDisplaySectionFullAutomation');
const headersDisplayFullAutomation = document.getElementById('headersDisplayFullAutomation');
const scanFieldsButtonFullAutomation = document.getElementById('scanFieldsButtonFullAutomation');
const scanMessageFullAutomation = document.getElementById('scanMessageFullAutomation');
const fieldMappingSectionFullAutomation = document.getElementById('fieldMappingSectionFullAutomation');
const mappingContainerFullAutomation = document.getElementById('mappingContainerFullAutomation');
const fillEmptyOnlyCheckboxFullAutomation = document.getElementById('fillEmptyOnlyCheckboxFullAutomation');
const startFullAutomationButton = document.getElementById("startFullAutomationButton");
const fullAutomationMessage = document.getElementById("fullAutomationMessage");


// DOM Elements - Theme Toggle
const themeToggle = document.getElementById('themeToggle');


// --- Event Listeners ---

// Tab switching logic
autoFillTab.addEventListener("click", () => switchTab('autoFill'));
autoClickTab.addEventListener("click", () => switchTab('autoClick'));
fullAutomationTab.addEventListener("click", () => switchTab('fullAutomation')); // New Tab Listener

// Theme toggle logic
themeToggle.addEventListener('change', () => {
    // Toggle 'dark' class on the body to apply dark mode styles
    const isDarkMode = themeToggle.checked;
    document.documentElement.classList.toggle('dark', isDarkMode); // Apply to html element

    // Get all elements that need their 'dark' class toggled based on the theme state (using querySelectorAll for all instances)
    const elementsToToggle = [
        document.querySelector('.main-container'),
        ...document.querySelectorAll('.card'),
        ...document.querySelectorAll('.section-heading'),
        ...document.querySelectorAll('.card-heading'),
        ...document.querySelectorAll('.action-button'),
        ...document.querySelectorAll('.form-input'),
        ...document.querySelectorAll('.drop-area'),
        ...document.querySelectorAll('.browse-button'),
        ...document.querySelectorAll('.file-status'),
        ...document.querySelectorAll('.headers-list'),
        ...document.querySelectorAll('.headers-list span'),
        ...document.querySelectorAll('.checkbox-label'),
        ...document.querySelectorAll('.radio-label'),
        ...document.querySelectorAll('.message-box'),
        ...document.querySelectorAll('.auto-mapped-badge'),
        ...document.querySelectorAll('.tab-buttons'),
        ...document.querySelectorAll('.tab-button'),
        document.getElementById('clickableButtonsContainer'), // Specific element
        ...document.querySelectorAll('#clickableButtonsContainer > div'),
        ...document.querySelectorAll('#clickableButtonsContainer label'),
        ...document.querySelectorAll('.selected-button-highlight'),
        ...document.querySelectorAll('.slider')
    ].filter(Boolean); // Filter out nulls if elements aren't always present

    elementsToToggle.forEach(el => {
        el.classList.toggle('dark', isDarkMode);
        // Special handling for selected-button-highlight on tab switch
        if (el.classList.contains('selected-button-highlight')) {
            el.classList.toggle('dark', isDarkMode); // Only toggle 'dark' on the element
        }
        // Special handling for tab buttons active state
        if (el.classList.contains('tab-button') && el.classList.contains('active')) {
            el.classList.add('dark:active');
        } else {
            el.classList.remove('dark:active');
        }
    });

    // Store user's theme preference in local storage
    localStorage.setItem('theme', isDarkMode ? 'dark' : 'light');
});

// File input change for AutoFill
fileInputAutoFill.addEventListener('change', (event) => handleFile(event, 'autoFill'));

// Drag and drop functionality for AutoFill file input
dropAreaAutoFill.addEventListener('dragover', (e) => {
    e.preventDefault();
    dropAreaAutoFill.classList.add('border-blue-600', 'bg-blue-100', 'dark:border-indigo-500', 'dark:bg-indigo-900');
    fileNameDisplayAutoFill.classList.add('group-hover:text-blue-700', 'dark:group-hover:text-blue-300'); 
});
dropAreaAutoFill.addEventListener('dragleave', (e) => {
    e.preventDefault();
    dropAreaAutoFill.classList.remove('border-blue-600', 'bg-blue-100', 'dark:border-indigo-500', 'dark:bg-indigo-900');
    fileNameDisplayAutoFill.classList.remove('group-hover:text-blue-700', 'dark:group-hover:text-blue-300');
});
dropAreaAutoFill.addEventListener('drop', (e) => {
    e.preventDefault();
    dropAreaAutoFill.classList.remove('border-blue-600', 'bg-blue-100', 'dark:border-indigo-500', 'dark:bg-indigo-900');
    fileNameDisplayAutoFill.classList.remove('group-hover:text-blue-700', 'dark:group-hover:text-blue-300');
    if (e.dataTransfer.files.length > 0) {
        fileInputAutoFill.files = e.dataTransfer.files;
        handleFile(null, 'autoFill'); // Pass null for event, use ID prefix
    }
});

// Scan fields button click for AutoFill
scanFieldsButtonAutoFill.addEventListener('click', async () => {
    await scanCurrentTabFields('autoFill');
});

// Fill data button click for AutoFill
fillDataButtonAutoFill.addEventListener('click', () => fillDataInTab('autoFill'));

// Test Fill button click for AutoFill
testFillButtonAutoFill.addEventListener('click', () => testFillFirstRow('autoFill'));

// Preview Values button click for AutoFill
previewValuesButtonAutoFill.addEventListener('click', () => previewMappedValues('autoFill'));


// Auto Click Event Listeners (existing)
scanButtons.addEventListener("click", async () => {
    // FIX: Changed to use displayMessage
    displayMessage(autoClickMessage, '<i class="fas fa-spinner fa-spin"></i>Scanning for clickable buttons...', 'info', true);
    scanButtons.disabled = true;
    scanButtons.innerHTML = 'Scanning... <span class="loading-spinner"></span>';
    clickableButtonsContainer.innerHTML = '<p class="text-gray-500 dark:text-gray-400 text-sm p-2">Scanning...</p>'; // Clear previous buttons and show scanning message

    try {
        const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });
        if (!tab) {
            // FIX: Changed to use displayMessage
            displayMessage(autoClickMessage, 'Could not get active tab.', 'error', false);
            return;
        }

        // Ensure content.js is injected only once per tab
        const loaded = await isContentScriptLoaded(tab.id);
        if (!loaded) {
            await chrome.scripting.executeScript({
                target: { tabId: tab.id },
                files: ['content.js']
            });
        }

        // Now that content.js is guaranteed to be loaded, send the actual scan message
        const response = await chrome.tabs.sendMessage(tab.id, { action: "scanClickables" });

        if (response && response.clickables) {
            if (response.clickables.length > 0) {
                clickableButtonsContainer.innerHTML = ''; // Clear scanning message
                response.clickables.forEach((btn, index) => {
                    const btnDiv = document.createElement("div");
                    btnDiv.className = "flex items-center mb-1 last:mb-0 border-b border-gray-200 dark:border-gray-600 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-md transition-colors duration-200 p-2";
                    btnDiv.innerHTML = `
                        <input type="radio" name="clickable" value="${btn.stableId}" id="btn-${index}" class="mr-2 flex-shrink-0">
                        <label for="btn-${index}" class="text-sm text-gray-700 dark:text-gray-300 flex-grow">${btn.text}</label>
                    `;
                    clickableButtonsContainer.appendChild(btnDiv);

                    // Add event listener to highlight selected radio button
                    btnDiv.querySelector('input[type="radio"]').addEventListener('change', (e) => {
                        // Remove highlight from all other buttons
                        document.querySelectorAll('#clickableButtonsContainer > div').forEach(div => {
                            div.classList.remove('selected-button-highlight');
                            // Ensure dark mode highlight is also removed/added correctly
                            div.classList.remove('dark'); 
                        });
                        // Add highlight to the newly selected button's parent div
                        if (e.target.checked) {
                            btnDiv.classList.add('selected-button-highlight');
                            if (document.documentElement.classList.contains('dark')) {
                                btnDiv.classList.add('dark');
                            }
                        }
                    });
                });
                selectButtonCard.classList.remove("hidden"); // Show Step 2 card
                clickControlSection.classList.remove("hidden"); // Show Step 3 card
                // FIX: Changed to use displayMessage
                displayMessage(autoClickMessage, `<i class="fas fa-check-circle"></i>Found ${response.clickables.length} clickable elements.`, 'success', true);
            } else {
                clickableButtonsContainer.innerHTML = "<p class='text-gray-500 dark:text-gray-400 text-sm p-2'>No clickable buttons found on this page.</p>";
                selectButtonCard.classList.add("hidden");
                clickControlSection.classList.add("hidden");
                // FIX: Changed to use displayMessage
                displayMessage(autoClickMessage, '<i class="fas fa-info-circle"></i>No clickable buttons found on the current tab.', 'info', true);
            }
        } else {
            clickableButtonsContainer.innerHTML = "<p class='text-gray-500 dark:text-gray-400 text-sm p-2'>Failed to scan for buttons.</p>";
            selectButtonCard.classList.add("hidden");
            clickControlSection.classList.add("hidden");
            // FIX: Changed to use displayMessage
            displayMessage(autoClickMessage, '<i class="fas fa-exclamation-triangle"></i>Failed to get clickable elements from the current tab. Ensure content script can run.', 'error', true);
        }
    } catch (error) {
        console.error("Error scanning buttons:", error);
        // FIX: Changed to use displayMessage
        displayMessage(autoClickMessage, `<i class="fas fa-exclamation-triangle"></i>Error scanning buttons: ${error.message}. Check console for details.`, 'error', true);
        clickableButtonsContainer.innerHTML = "<p class='text-gray-500 dark:text-gray-400 text-sm p-2'>Error scanning for buttons. Check console for details.</p>";
        selectButtonCard.classList.add("hidden");
        clickControlSection.classList.add("hidden");
    } finally {
        scanButtons.disabled = false;
        scanButtons.innerHTML = '<i class="fas fa-sync-alt mr-2"></i>Scan for Clickable Buttons';
    }
});

startClickingButton.addEventListener("click", async () => {
    const count = parseInt(clickCountInput.value);
    const selected = document.querySelector('input[name="clickable"]:checked');
    const stableId = selected?.value;

    if (isNaN(count) || count < 1) {
        displayMessage(autoClickMessage, "Please enter a valid number of clicks (1 or more).", "error", false);
        return;
    }

    if (!stableId) {
        displayMessage(autoClickMessage, "Please select a button to click.", "error", false);
        return;
    }

    // FIX: Changed to use displayMessage
    displayMessage(autoClickMessage, `<i class="fas fa-circle-notch fa-spin"></i>Attempting to click ${count} time(s)...`, 'info', true);
    startClickingButton.disabled = true;
    startClickingButton.innerHTML = 'Clicking... <span class="loading-spinner"></span>';


    try {
        const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });
        if (!tab) {
            displayMessage(autoClickMessage, 'Could not get active tab.', 'error', false);
            return;
        }

        // Send message to content script to perform the clicks
        const response = await chrome.tabs.sendMessage(tab.id, {
            action: "performClick",
            stableId,
            count
        });

        if (response?.status === "success") {
            displayMessage(autoClickMessage, `<i class="fas fa-check-circle"></i>Clicked ${count} time(s) successfully.`, "success", true);
        } else {
            console.error(`Error during click: ${response?.message || 'Unknown error.'}`);
            displayMessage(autoClickMessage, `<i class="fas fa-exclamation-triangle"></i>Failed to click: ${response?.message || 'Unknown error.'}`, "error", true);
        }
    } catch (error) {
        console.error("Error performing click:", error);
        displayMessage(autoClickMessage, `<i class="fas fa-exclamation-triangle"></i>Error performing click: ${error.message}.`, "error", true);
    } finally {
        startClickingButton.disabled = false;
        startClickingButton.innerHTML = '<i class="fas fa-bullseye mr-2"></i>Start Clicking';
    }
});


// Full Automation Event Listeners (new)
fileInputFullAutomation.addEventListener('change', (event) => handleFile(event, 'fullAutomation'));
dropAreaFullAutomation.addEventListener('dragover', (e) => {
    e.preventDefault();
    dropAreaFullAutomation.classList.add('border-blue-600', 'bg-blue-100', 'dark:border-indigo-500', 'dark:bg-indigo-900');
    fileNameDisplayFullAutomation.classList.add('group-hover:text-blue-blue-700', 'dark:group-hover:text-blue-300'); 
});
dropAreaFullAutomation.addEventListener('dragleave', (e) => {
    e.preventDefault();
    dropAreaFullAutomation.classList.remove('border-blue-600', 'bg-blue-100', 'dark:border-indigo-500', 'dark:bg-indigo-900');
    fileNameDisplayFullAutomation.classList.remove('group-hover:text-blue-blue-700', 'dark:group-hover:text-blue-300');
});
dropAreaFullAutomation.addEventListener('drop', (e) => {
    e.preventDefault();
    dropAreaFullAutomation.classList.remove('border-blue-600', 'bg-blue-100', 'dark:border-indigo-500', 'dark:bg-indigo-900');
    fileNameDisplayFullAutomation.classList.remove('group-hover:text-blue-blue-700', 'dark:group-hover:text-blue-300');
    if (e.dataTransfer.files.length > 0) {
        fileInputFullAutomation.files = e.dataTransfer.files;
        handleFile(null, 'fullAutomation');
    }
});

scanFieldsButtonFullAutomation.addEventListener('click', async () => {
    await scanCurrentTabFields('fullAutomation');
});

startFullAutomationButton.addEventListener('click', startFullAutomation);


// Load learned mappings and initial tab on startup
document.addEventListener('DOMContentLoaded', () => {
    loadLearnedMappings();
    loadTabPreference();
    // Load theme preference on DOMContentLoaded and apply it immediately
    const theme = localStorage.getItem('theme');
    if (theme === 'dark') {
      themeToggle.checked = true; // Set the toggle to checked state
    }
    // Manually trigger the change event to apply the theme classes on initial load
    // This ensures all dynamically added elements (like file status, mapping groups) also get the correct theme
    themeToggle.dispatchEvent(new Event('change'));
});


// --- Functions ---

/**
 * Switches between the Auto Fill, Auto Click, and Full Automation tabs.
 * @param {string} activeTabId - The ID of the tab to activate ('autoFill', 'autoClick', or 'fullAutomation').
 */
async function switchTab(activeTabId) {
    // Remove active class from all tabs and add to the selected one
    autoFillTab.classList.remove('active', 'dark:active');
    autoClickTab.classList.remove('active', 'dark:active');
    fullAutomationTab.classList.remove('active', 'dark:active'); // New tab

    const targetTabButton = document.getElementById(`${activeTabId}Tab`); // Get the correct tab button
    targetTabButton.classList.add('active');
    // Ensure dark mode active class is applied if current theme is dark
    if (document.documentElement.classList.contains('dark')) {
        targetTabButton.classList.add('dark:active');
    }

    // Hide all tab sections and show the selected one
    autoFillSection.classList.add('hidden');
    autoClickSection.classList.add('hidden');
    fullAutomationSection.classList.add('hidden'); // New section
    document.getElementById(`${activeTabId}Section`).classList.remove('hidden');

    // Save tab preference to chrome.storage.sync
    try {
        await chrome.storage.sync.set({ activeTab: activeTabId });
    } catch (error) {
        console.error('Error saving tab preference:', error);
    }
}

/**
 * Loads the last active tab preference from chrome.storage.sync.
 */
async function loadTabPreference() {
    try {
        const result = await chrome.storage.sync.get('activeTab');
        const lastActiveTab = result.activeTab || 'autoFill'; // Default to autoFill
        switchTab(lastActiveTab);
    } catch (error) {
        console.error('Error loading tab preference:', error);
        switchTab('autoFill'); // Fallback to default in case of error
    }
}


/**
 * Handles the file selection and reads its content.
 * @param {Event} event - The file input change event.
 * @param {string} targetSection - 'autoFill' or 'fullAutomation' to identify which section triggered the upload.
 */
function handleFile(event, targetSection) {
    const fileInputElem = targetSection === 'autoFill' ? fileInputAutoFill : fileInputFullAutomation;
    const fileNameDisplayElem = targetSection === 'autoFill' ? fileNameDisplayAutoFill : fileNameDisplayFullAutomation;
    const rowCountDisplayElem = targetSection === 'autoFill' ? rowCountDisplayAutoFill : rowCountDisplayFullAutomation;
    const fileStatusMessageElem = targetSection === 'autoFill' ? fileStatusMessageAutoFill : fileStatusMessageFullAutomation;
    const fileMessageElem = targetSection === 'autoFill' ? fileMessageAutoFill : fileMessageFullAutomation;
    const fileStatusIconElem = targetSection === 'autoFill' ? fileStatusIconAutoFill : fileStatusIconFullAutomation;
    const dataDisplaySectionElem = targetSection === 'autoFill' ? dataDisplaySectionAutoFill : dataDisplaySectionFullAutomation;

    const file = fileInputElem.files[0];
    if (!file) {
        displayFileStatusMessage('<i class="fas fa-exclamation-triangle"></i>No file selected.', 'error', fileStatusMessageElem, fileMessageElem, fileStatusIconElem, true);
        return;
    }

    fileNameDisplayElem.textContent = `File: "${file.name}"`; // Update text to show file name
    displayFileStatusMessage(`<i class="fas fa-spinner fa-spin"></i>Reading "${file.name}"...`, 'info', fileStatusMessageElem, fileMessageElem, fileStatusIconElem, true);

    const reader = new FileReader();

    reader.onload = function(e) {
        try {
            const data = new Uint8Array(e.target.result);
            // Read the workbook using SheetJS
            workbook = XLSX.read(data, { type: 'array' });

            // Get the first sheet name
            const sheetName = workbook.SheetNames[0];
            // Convert the first sheet to JSON, ensuring header:1 to get raw array of arrays
            sheetData = XLSX.utils.sheet_to_json(workbook.Sheets[sheetName], { header: 1 });

            if (sheetData.length === 0) {
                displayFileStatusMessage('<i class="fas fa-exclamation-triangle"></i>The selected file is empty or could not be parsed.', 'error', fileStatusMessageElem, fileMessageElem, fileStatusIconElem, true);
                dataDisplaySectionElem.classList.add('hidden');
                rowCountDisplayElem.classList.add('hidden');
                return;
            }

            // The first row is the headers
            headers = sheetData[0];
            
            // Calculate non-empty data rows
            let nonEmtpyDataRowsCount = 0;
            // Start from the second row (index 1) to skip headers
            for (let i = 1; i < sheetData.length; i++) {
                const row = sheetData[i];
                // Check if the row contains at least one non-empty cell
                // A cell is considered non-empty if its string representation after trimming is not empty
                const isRowNonEmpty = row.some(cell => String(cell).trim() !== '');
                if (isRowNonEmpty) {
                    nonEmtpyDataRowsCount++;
                }
            }

            // Store the actual non-empty data row count in the global variable
            actualNonEmptyDataRowsCount = nonEmtpyDataRowsCount;

            rowCountDisplayElem.textContent = `Data Rows: ${actualNonEmptyDataRowsCount}`;
            rowCountDisplayElem.classList.remove('hidden'); // Show row count

            displayHeaders(headers, targetSection); // Update UI with headers
            dataDisplaySectionElem.classList.remove('hidden');
            displayFileStatusMessage(`<i class="fas fa-check-circle"></i>File "${file.name}" loaded successfully.`, 'success', fileStatusMessageElem, fileMessageElem, fileStatusIconElem, true);

            // If fields were already scanned, re-setup mapping with new headers and re-auto-map
            if (Object.keys(groupedFormFields).length > 0) { // Check groupedFormFields for existing scan
                setupFieldMapping(groupedFormFields, headers, targetSection); // Re-setup mapping with new headers
                autoMapFields(groupedFormFields, headers, targetSection); // Re-run auto-map
                (targetSection === 'autoFill' ? fieldMappingSectionAutoFill : fieldMappingSectionFullAutomation).classList.remove('hidden');
            }

        } catch (error) {
            console.error("Error reading file:", error);
            displayFileStatusMessage(`<i class="fas fa-exclamation-triangle"></i>Error reading file: ${error.message}. Please ensure it's a valid spreadsheet format.`, 'error', fileStatusMessageElem, fileMessageElem, fileStatusIconElem, true);
            dataDisplaySectionElem.classList.add('hidden');
            rowCountDisplayElem.classList.add('hidden');
        }
    };

    reader.onerror = function(e) {
        console.error("FileReader error:", e);
        displayFileStatusMessage(`<i class="fas fa-exclamation-triangle"></i>Error reading file: ${e.target.error.name}.`, 'error', fileStatusMessageElem, fileMessageElem, fileStatusIconElem, true);
        dataDisplaySectionElem.classList.add('hidden');
        rowCountDisplayElem.classList.add('hidden');
    };

    reader.readAsArrayBuffer(file);
}

/**
 * Displays the extracted headers in the UI for the specified section.
 * @param {string[]} headersArray - Array of header strings.
 * @param {string} targetSection - 'autoFill' or 'fullAutomation'.
 */
function displayHeaders(headersArray, targetSection) {
    const headersDisplayElem = targetSection === 'autoFill' ? headersDisplayAutoFill : headersDisplayFullAutomation;
    headersDisplayElem.innerHTML = ''; // Clear previous headers
    if (headersArray.length > 0) {
        headersArray.forEach(header => {
            const span = document.createElement('span');
            // Apply semantic classes and then toggle 'dark' based on current theme
            span.className = `px-5 py-2 rounded-full text-base font-medium shadow-sm flex items-center transition-colors duration-200 cursor-default`;
            if (document.documentElement.classList.contains('dark')) {
                span.classList.add('dark'); // Explicitly add dark class for CSS to pick up
            }
            span.textContent = header;
            headersDisplayElem.appendChild(span);
        });
    } else {
        headersDisplayElem.textContent = 'No headers found in the first row.';
        // This text is plain, will inherit body text color which is already themed.
        headersDisplayElem.classList.add('text-gray-500', 'dark:text-gray-400', 'text-sm');
    }
}

/**
 * Sends a message to the content script to scan for form fields.
 * @param {string} targetSection - 'autoFill' or 'fullAutomation'.
 */
async function scanCurrentTabFields(targetSection) {
    const scanMessageElem = targetSection === 'autoFill' ? scanMessageAutoFill : scanMessageFullAutomation;
    const scanFieldsButtonElem = targetSection === 'autoFill' ? scanFieldsButtonAutoFill : scanFieldsButtonFullAutomation;
    const fieldMappingSectionElem = targetSection === 'autoFill' ? fieldMappingSectionAutoFill : fieldMappingSectionFullAutomation;

    if (!headers || headers.length === 0) {
        displayMessage(scanMessageElem, '<i class="fas fa-exclamation-triangle mr-2"></i>Please upload a file with headers first.', 'error', true);
        return;
    }

    displayMessage(scanMessageElem, '<i class="fas fa-spinner fa-spin mr-2"></i>Scanning current tab for fields...', 'info', true);
    scanFieldsButtonElem.disabled = true; // Disable button during scan
    scanFieldsButtonElem.innerHTML = 'Scanning... <span class="loading-spinner"></span>';

    try {
        const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });
        if (!tab) {
            displayMessage(scanMessageElem, 'Could not get active tab.', 'error', false);
            return;
        }

        // Ensure content.js is injected only once per tab
        const loaded = await isContentScriptLoaded(tab.id);
        if (!loaded) {
            await chrome.scripting.executeScript({
                target: { tabId: tab.id },
                files: ['content.js']
            });
        }

        // Now that content.js is guaranteed to be loaded, send the actual scan message
        const response = await chrome.tabs.sendMessage(tab.id, { action: 'scanFields' });

        if (response && response.fields) {
            availableFormFields = response.fields;
            if (availableFormFields.length > 0) {
                groupedFormFields = groupFieldsBySignature(availableFormFields); // Use smarter grouping
                setupFieldMapping(groupedFormFields, headers, targetSection); // Call existing setup to build UI with grouped fields
                autoMapFields(groupedFormFields, headers, targetSection); // Call auto-map to pre-select dropdowns for groups
                fieldMappingSectionElem.classList.remove('hidden');
                displayMessage(scanMessageElem, `<i class="fas fa-check-circle mr-2"></i>Found ${availableFormFields.length} fields on the page, grouped into ${Object.keys(groupedFormFields).length} sections. Attempting auto-mapping.`, 'success', true);
            } else {
                fieldMappingSectionElem.classList.add('hidden');
                displayMessage(scanMessageElem, '<i class="fas fa-info-circle mr-2"></i>No input fields found on the current tab.', 'info', true);
            }
        } else {
            fieldMappingSectionElem.classList.add('hidden');
            displayMessage(scanMessageElem, '<i class="fas fa-exclamation-triangle mr-2"></i>Failed to get fields from the current tab. Ensure content script can run.', 'error', true);
        }
    } catch (error) {
        console.error("Error scanning fields:", error);
        displayMessage(scanMessageElem, `<i class="fas fa-exclamation-triangle mr-2"></i>Error scanning fields: ${error.message}.`, 'error', true);
        fieldMappingSectionElem.classList.add('hidden');
    } finally {
        scanFieldsButtonElem.disabled = false;
        scanFieldsButtonElem.innerHTML = '<i class="fas fa-sync-alt mr-2"></i>Scan Current Tab for Fields';
    }
}

/**
 * Generates a comprehensive signature for a form field using multiple attributes.
 * This signature is used for smarter grouping and fuzzy matching.
 * @param {Object} field - The field object from content.js.
 * @returns {string} A combined string representing the field's unique signature.
 */
function generateFieldSignature(field) {
    const parts = [
        field.labelText,
        field.name,
        field.placeholder,
        field.ariaLabel,
        field.title,
        field.autocomplete,
        field.surroundingText
    ].filter(Boolean) // Filter out empty strings/nulls/undefineds
     .map(str => str.toLowerCase().replace(/[^a-z0-9\s]/g, '').trim()) // Clean and normalize strings
     .filter(str => str.length > 1); // Only include parts longer than 1 character

    // Use a Set to ensure unique parts and then join them
    return [...new Set(parts)].join(" | ");
}

/**
 * Groups form fields by their generated signature to create logical sections.
 * @param {Array<Object>} formFields - Array of field objects from content.js.
 * @returns {Object} An object where keys are grouping contexts (signatures) and values are arrays of fields.
 */
function groupFieldsBySignature(formFields) {
    const groups = {};
    formFields.forEach(field => {
        const signature = generateFieldSignature(field);
        // Fallback to htmlId if signature is empty, otherwise a generic label
        const groupIdentifier = signature || field.htmlId || `Unnamed Field Group (${field.type})`;
        
        if (!groups[groupIdentifier]) {
            groups[groupIdentifier] = [];
        }
        groups[groupIdentifier].push(field);
    });
    return groups;
}

/**
 * Sets up the mapping section with dropdowns for each grouped form field context.
 * @param {Object} groupedFields - Object of grouped fields (e.g., { 'Context A': [field1, field2], 'Context B': [field3] }).
 * @param {string[]} headersArray - Array of header strings for dropdown options.
 * @param {string} targetSection - 'autoFill' or 'fullAutomation'.
 */
function setupFieldMapping(groupedFields, headersArray, targetSection) {
    const mappingContainerElem = targetSection === 'autoFill' ? mappingContainerAutoFill : mappingContainerFullAutomation;
    mappingContainerElem.innerHTML = ''; // Clear previous mappings

    const groupKeys = Object.keys(groupedFields);
    if (groupKeys.length === 0) {
        mappingContainerElem.textContent = 'No mappable field groups found on the page.';
        mappingContainerElem.classList.add('text-gray-500', 'dark:text-gray-400', 'text-sm');
        return;
    }
    // Remove informational text if there are groups to display
    mappingContainerElem.classList.remove('text-gray-500', 'dark:text-gray-400', 'text-sm');

    groupKeys.forEach(contextKey => {
        const fieldsInGroup = groupedFields[contextKey];
        const mappingGroupItem = document.createElement('div');
        // Apply card styling and theme class
        mappingGroupItem.className = `field-mapping-group-item card ${document.documentElement.classList.contains('dark') ? 'dark' : ''}`;
        
        const groupHeader = document.createElement('h3');
        groupHeader.className = `text-md font-semibold text-gray-800 dark:text-gray-200 mb-3 flex items-center card-heading ${document.documentElement.classList.contains('dark') ? 'dark' : ''}`;
        groupHeader.textContent = contextKey;
        mappingGroupItem.appendChild(groupHeader);

        const groupControl = document.createElement('div');
        groupControl.className = 'flex flex-col sm:flex-row items-start sm:items-center space-y-2 sm:space-y-0 sm:space-x-2 mb-3';

        const label = document.createElement('label');
        // Apply theme class to label
        label.className = `checkbox-label flex-shrink-0 ${document.documentElement.classList.contains('dark') ? 'dark' : ''}`;
        
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.className = 'group-checkbox mr-2';
        checkbox.dataset.contextKey = contextKey;
        checkbox.checked = false; // Initially unchecked

        const span = document.createElement('span');
        span.className = 'text-sm text-gray-700 dark:text-gray-300';
        span.textContent = `Map fields for "${contextKey}"`;

        label.appendChild(checkbox);
        label.appendChild(span);
        groupControl.appendChild(label);

        const select = document.createElement('select');
        // Apply form-input and theme class to select
        select.className = `group-mapper flex-grow mt-2 sm:mt-0 form-input ${document.documentElement.classList.contains('dark') ? 'dark' : ''}`;
        select.dataset.contextKey = contextKey;
        select.disabled = true; // Initially disabled

        const fragment = document.createDocumentFragment();
        const defaultOption = document.createElement('option');
        defaultOption.value = '';
        defaultOption.textContent = '-- Select Column --';
        fragment.appendChild(defaultOption);

        headersArray.forEach(header => {
            const option = document.createElement('option');
            option.value = header;
            option.textContent = header;
            fragment.appendChild(option);
        });
        select.appendChild(fragment);
        groupControl.appendChild(select);
        mappingGroupItem.appendChild(groupControl);

        mappingContainerElem.appendChild(mappingGroupItem);

        // Event listener for group checkbox: enables/disables the select dropdown
        checkbox.addEventListener('change', (e) => {
            const currentSelect = mappingContainerElem.querySelector(`.group-mapper[data-context-key="${e.target.dataset.contextKey}"]`);
            currentSelect.disabled = !e.target.checked;
            if (!e.target.checked) {
                currentSelect.value = ''; // Reset selection if unchecked
                removeAutoMappedBadge(groupHeader); // Remove badge when unchecked
            } else {
                // If re-checked, try auto-mapping again for visual consistency (e.g., if user changed it manually and then re-enabled)
                autoMapFields(groupedFields, headersArray, targetSection); 
            }
        });

        // Event listener for select change to save mapping and update badge
        select.addEventListener('change', () => {
            saveLearnedMappings(); // Save whenever a mapping is changed by the user
            // Update badge based on current selection, assuming it's a manual selection if changed here
            const selectedHeader = select.value;
            if (selectedHeader) {
                updateBadgeForGroup(groupHeader, 'learned', ''); // Indicate it's now a learned mapping
            } else {
                removeAutoMappedBadge(groupHeader); // Remove badge if selection is cleared
            }
        });
    });
}

/**
 * Performs intelligent auto-mapping between grouped form fields and spreadsheet headers using Fuse.js.
 * Populates the mapping dropdowns and checks the corresponding checkboxes for groups.
 * @param {Object} groupedFields - Object of grouped fields.
 * @param {string[]} headersArray - Array of header strings.
 * @param {string} targetSection - 'autoFill' or 'fullAutomation'.
 */
async function autoMapFields(groupedFields, headersArray, targetSection) {
    const scanMessageElem = targetSection === 'autoFill' ? scanMessageAutoFill : scanMessageFullAutomation;
    const mappingContainerElem = targetSection === 'autoFill' ? mappingContainerAutoFill : mappingContainerFullAutomation;

    await loadLearnedMappings(); // Ensure learned mappings are loaded first

    // Guard against empty headers array for Fuse.js initialization
    if (!headersArray || headersArray.length === 0) {
        console.warn("Headers array is empty, cannot perform auto-mapping.");
        displayMessage(scanMessageElem, '<i class="fas fa-info-circle mr-2"></i>Cannot auto-map: No headers found in the uploaded file.', 'info', true);
        return;
    }

    const fuseOptions = {
        includeScore: true,
        threshold: 0.4, // Lower is stricter, 0.4 allows for some flexibility
        keys: ['header'] // Fuse will search within the 'header' property of our items
    };

    // Prepare headers for Fuse.js search
    const fuse = new Fuse(headersArray.map(h => ({ header: h })), fuseOptions);

    let autoMappedCount = 0;
    Object.keys(groupedFields).forEach(contextKey => {
        const checkbox = mappingContainerElem.querySelector(`.group-checkbox[data-context-key="${contextKey}"]`);
        const select = mappingContainerElem.querySelector(`.group-mapper[data-context-key="${contextKey}"]`);
        const groupHeaderElement = checkbox.closest('.field-mapping-group-item').querySelector('h3');

        if (!checkbox || !select) return; // Skip if elements not found

        let mappedType = 'unmapped'; // Default mapping type

        // 1. Prioritize applying a previously learned mapping
        if (learnedMappings[contextKey] && headersArray.includes(learnedMappings[contextKey])) {
            checkbox.checked = true;
            select.disabled = false;
            select.value = learnedMappings[contextKey];
            mappedType = 'learned';
            autoMappedCount++;
            console.log(`Auto-mapping (Learned): "${contextKey}" -> "${learnedMappings[contextKey]}"`);
        } else {
            // 2. Fallback to fuzzy matching if no learned mapping or learned mapping is no longer valid (e.g., header changed)
            const result = fuse.search(contextKey)[0]; // Get the best fuzzy match
            if (result && result.score < 0.4) { // Apply if confidence (score) is high enough
                const bestMatchHeader = result.item.header;
                checkbox.checked = true;
                select.disabled = false;
                select.value = bestMatchHeader;
                mappedType = 'fuzzy';
                autoMappedCount++;
                console.log(`Auto-mapping (Fuzzy): "${contextKey}" -> "${bestMatchHeader}" (Score: ${result.score.toFixed(2)})`);
            } else {
                // If no auto-mapping, ensure checkbox is unchecked and select is disabled and reset
                checkbox.checked = false;
                select.disabled = true;
                select.value = '';
                mappedType = 'unmapped';
                console.log(`No strong auto-mapping for "${contextKey}" (Best score: ${result?.score.toFixed(2) || 'N/A'})`);
            }
        }
        // Update the visual badge for the group based on the mapping type
        updateBadgeForGroup(groupHeaderElement, mappedType, mappedType === 'fuzzy' ? result.score.toFixed(2) : '');
    });
    // Display overall auto-mapping success message
    displayMessage(scanMessageElem, `<i class="fas fa-check-circle mr-2"></i>Auto-mapping complete. ${autoMappedCount} fields auto-mapped. Review and adjust if needed.`, 'success', true);
}

/**
 * Adds or updates an "Auto-Matched" badge to the group header.
 * @param {HTMLElement} groupHeaderElement - The H3 element of the group.
 * @param {'learned'|'fuzzy'|'unmapped'} type - The type of mapping.
 * @param {string} [scoreText=''] - Optional score text for fuzzy matches.
 */
function updateBadgeForGroup(groupHeaderElement, type, scoreText = '') {
    let badge = groupHeaderElement.querySelector('.auto-mapped-badge');
    if (!badge) {
        badge = document.createElement('span');
        badge.className = 'auto-mapped-badge';
        groupHeaderElement.appendChild(badge);
    }
    
    // Remove all type classes first to ensure only the current one is applied
    badge.classList.remove('learned', 'fuzzy', 'unmapped');
    // Add the current type class
    badge.classList.add(type);
    
    // Apply dark mode class to the badge if the body is in dark mode
    if (document.documentElement.classList.contains('dark')) {
        badge.classList.add('dark');
    } else {
        badge.classList.remove('dark');
    }

    let badgeText = '';
    if (type === 'learned') {
        badgeText = 'Auto-Matched (Learned)';
    } else if (type === 'fuzzy') {
        badgeText = `Auto-Matched (Score: ${scoreText})`;
    } else { // 'unmapped'
        badgeText = 'Unmapped';
    }
    badge.textContent = badgeText;

    // Hide badge if unmapped or no selection in the dropdown
    const selectElement = groupHeaderElement.parentElement.querySelector('.group-mapper');
    if (type === 'unmapped' || (selectElement && !selectElement.value)) {
        badge.classList.add('hidden');
    } else {
        badge.classList.remove('hidden');
    }
}

/**
 * Removes the auto-mapped badge from a group header.
 * @param {HTMLElement} groupHeaderElement - The H3 element of the group.
 */
function removeAutoMappedBadge(groupHeaderElement) {
    const badge = groupHeaderElement.querySelector('.auto-mapped-badge'); // Select the badge within the group header
    if (badge) {
        badge.classList.add('hidden'); // Simply hide it
    }
}

/**
 * Saves the currently selected mappings to chrome.storage.sync for future use.
 */
async function saveLearnedMappings() {
    const currentMappings = {};
    // Iterate over both autoFill and fullAutomation mapping containers
    [mappingContainerAutoFill, mappingContainerFullAutomation].forEach(container => {
        container.querySelectorAll('.group-checkbox:checked').forEach(checkbox => {
            const contextKey = checkbox.dataset.contextKey;
            const selectElement = container.querySelector(`.group-mapper[data-context-key="${contextKey}"]`);
            const mappedColumnHeader = selectElement ? selectElement.value : '';
            if (mappedColumnHeader) {
                currentMappings[contextKey] = mappedColumnHeader;
            }
        });
    });

    try {
        await chrome.storage.sync.set({ learnedMappings: currentMappings });
        console.log('Learned mappings saved:', currentMappings);
        // After saving, re-run autoMapFields to update badges based on newly learned mappings
        if (Object.keys(groupedFormFields).length > 0 && headers.length > 0) { // Check if fields and headers exist
            // This will ensure badges are updated across both tabs if necessary
            autoMapFields(groupedFormFields, headers, 'autoFill'); 
            autoMapFields(groupedFormFields, headers, 'fullAutomation');
        }
    }
    catch (error) {
        console.error('Error saving learned mappings:', error);
    }
}

/**
 * Loads learned mappings from chrome.storage.sync.
 */
async function loadLearnedMappings() {
    try {
        const result = await chrome.storage.sync.get('learnedMappings');
        learnedMappings = result.learnedMappings || {};
        console.log('Learned mappings loaded:', learnedMappings);
    } catch (error) {
        console.error('Error loading learned mappings:', error);
    }
}

/**
 * Sends a message to the content script to fill the fields on the active tab.
 * @param {string} targetSection - 'autoFill' or 'fullAutomation'.
 * This function now iterates through spreadsheet rows and prepares a batch for filling.
 */
async function fillDataInTab(targetSection) {
    const fillDataMessageElem = targetSection === 'autoFill' ? fillDataMessageAutoFill : fullAutomationMessage; // Use fullAutomationMessage for fullAutomation section
    const fillDataButtonElem = targetSection === 'autoFill' ? fillDataButtonAutoFill : startFullAutomationButton; // For disabling
    const fillEmptyOnlyCheckboxElem = targetSection === 'autoFill' ? fillEmptyOnlyCheckboxAutoFill : fillEmptyOnlyCheckboxFullAutomation;
    const mappingContainerElem = targetSection === 'autoFill' ? mappingContainerAutoFill : mappingContainerFullAutomation;

    if (!workbook || sheetData.length <= 1) { // sheetData includes headers, so >1 means actual data rows
        displayMessage(fillDataMessageElem, '<i class="fas fa-exclamation-triangle mr-2"></i>Please upload a spreadsheet file first.', 'error', true);
        return;
    }
    if (Object.keys(groupedFormFields).length === 0) {
        displayMessage(fillDataMessageElem, '<i class="fas fa-exclamation-triangle mr-2"></i>Please scan for fields on the current tab first.', 'error', true);
        return;
    }

    const actualDataRows = sheetData.slice(1); // Get data rows, excluding headers

    const fillEmptyOnly = fillEmptyOnlyCheckboxElem.checked;
    
    // Collect all selected mappings: { contextKey: mappedColumnHeader }
    const selectedMappings = {};
    mappingContainerElem.querySelectorAll('.group-checkbox:checked').forEach(checkbox => {
        const contextKey = checkbox.dataset.contextKey;
        const selectElement = mappingContainerElem.querySelector(`.group-mapper[data-context-key="${contextKey}"]`);
        const mappedColumnHeader = selectElement ? selectElement.value : '';
        if (mappedColumnHeader) {
            selectedMappings[contextKey] = mappedColumnHeader;
        }
    });

    if (Object.keys(selectedMappings).length === 0) {
        displayMessage(fillDataMessageElem, '<i class="fas fa-info-circle mr-2"></i>No fields selected for filling or no column mapped to selected groups.', 'error', true);
        return;
    }

    displayMessage(fillDataMessageElem, '<i class="fas fa-spinner fa-spin mr-2"></i>Preparing data for filling...', 'info', true);
    // Disable buttons to prevent multiple submissions
    fillDataButtonElem.disabled = true;
    fillDataButtonElem.innerHTML = 'Filling... <span class="loading-spinner"></span>';
    
    // Only disable test/preview buttons if in autofill section
    if (targetSection === 'autoFill') {
        testFillButtonAutoFill.disabled = true;
        previewValuesButtonAutoFill.disabled = true;
    }


    try {
        const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });
        if (!tab) {
            displayMessage(fillDataMessageElem, 'Could not get active tab.', 'error', false);
            return;
        }

        const dataBatch = []; // This will hold all field-value pairs to send to content.js

        // Iterate through each data row from the spreadsheet
        actualDataRows.forEach((spreadsheetRow, rowIndex) => {
            // For each mapped field type (contextKey), try to find and prepare data for its instances
            for (const contextKey in selectedMappings) {
                const mappedColumnHeader = selectedMappings[contextKey];
                const columnIndex = headers.indexOf(mappedColumnHeader);

                if (columnIndex !== -1) {
                    // Get all field instances for this group
                    const fieldsInThisGroup = groupedFormFields[contextKey];
                    // IMPORTANT: Assuming sequential filling. Target the Nth instance for the Nth spreadsheet row.
                    // If a form has multiple instances of the same field group, this fills them in order.
                    const targetField = fieldsInThisGroup[rowIndex]; 

                    if (targetField) {
                        const value = spreadsheetRow[columnIndex]; // Get value from spreadsheet cell
                        dataBatch.push({
                            id: targetField.id,
                            value: (value !== undefined && value !== null) ? String(value) : ''
                        });
                    } else {
                        // Log a warning if a corresponding form field instance isn't found for a spreadsheet row
                        console.warn(`No form field instance found for group "${contextKey}" at form row index ${rowIndex}. This spreadsheet row might not have a corresponding form field instance.`);
                    }
                } else {
                    // Log a warning if a mapped column header is not found in the spreadsheet headers
                    console.warn(`Mapped column "${mappedColumnHeader}" not found in headers for group "${contextKey}". Skipping.`);
                }
            }
        });

        if (dataBatch.length === 0) {
            displayMessage(fillDataMessageElem, '<i class="fas fa-info-circle mr-2"></i>No data prepared for filling based on current mappings and spreadsheet data. Check your mappings and file content.', 'info', true);
            return;
        }

        displayMessage(fillDataMessageElem, `<i class="fas fa-paper-plane mr-2"></i>Sending ${dataBatch.length} fields for filling...`, 'info', true);

        // Send the entire prepared batch to the content script for filling
        const response = await chrome.tabs.sendMessage(tab.id, {
            action: 'fillBatch',
            dataBatch: dataBatch, // Array of {id, value} pairs
            fillEmptyOnly: fillEmptyOnly
        });

        if (response && response.status === 'success') {
            displayMessage(fillDataMessageElem, `<i class="fas fa-check-circle mr-2"></i>Data filling complete! ${response.filledCount} fields filled, ${response.skippedCount} fields skipped.`, 'success', true);
            saveLearnedMappings(); // Save successful mappings for future use
        } else {
            console.error(`Error filling data: ${response?.message || 'Unknown error.'}`);
            displayMessage(fillDataMessageElem, `<i class="fas fa-exclamation-triangle"></i>Error filling data: ${response?.message || 'Unknown error.'}`, "error", true);
        }

    } catch (error) {
        console.error("Error filling data:", error);
        displayMessage(fillDataMessageElem, `<i class="fas fa-exclamation-triangle"></i>Error filling data: ${error.message}.`, 'error', true);
    } finally {
        // Re-enable buttons regardless of success or failure
        fillDataButtonElem.disabled = false;
        fillDataButtonElem.innerHTML = targetSection === 'autoFill' ? '<i class="fas fa-paper-plane mr-2"></i>Fill Data' : '<i class="fas fa-play mr-2"></i>Start Full Automation';
        
        if (targetSection === 'autoFill') {
            testFillButtonAutoFill.disabled = false;
            previewValuesButtonAutoFill.disabled = false;
        }
    }
}

/**
 * Fills only the first row of data for testing purposes.
 * @param {string} targetSection - 'autoFill' or 'fullAutomation'.
 */
async function testFillFirstRow(targetSection) {
    const testFillMessageElem = targetSection === 'autoFill' ? testFillMessageAutoFill : fullAutomationMessage; // Using fullAutomationMessage for this for now, though it's typically for AutoFill
    const testFillButtonElem = targetSection === 'autoFill' ? testFillButtonAutoFill : null; // Only exists in AutoFill tab
    const fillEmptyOnlyCheckboxElem = targetSection === 'autoFill' ? fillEmptyOnlyCheckboxAutoFill : fillEmptyOnlyCheckboxFullAutomation;
    const mappingContainerElem = targetSection === 'autoFill' ? mappingContainerAutoFill : mappingContainerFullAutomation;


    if (!workbook || sheetData.length <= 1) {
        displayMessage(testFillMessageElem, '<i class="fas fa-exclamation-triangle mr-2"></i>Please upload a spreadsheet file with data first.', 'error', true);
        return;
    }
    if (Object.keys(groupedFormFields).length === 0) {
        displayMessage(testFillMessageElem, '<i class="fas fa-exclamation-triangle mr-2"></i>Please scan for fields on the current tab first.', 'error', true);
        return;
    }

    const firstDataRow = sheetData[1]; // Get the first data row (index 1 after headers)
    if (!firstDataRow) {
        displayMessage(testFillMessageElem, '<i class="fas fa-info-circle mr-2"></i>No data rows found in the spreadsheet for testing.', 'error', true);
        return;
    }

    const fillEmptyOnly = fillEmptyOnlyCheckboxElem.checked;
    const dataToFillForFirstRow = [];

    const selectedMappings = {};
    mappingContainerElem.querySelectorAll('.group-checkbox:checked').forEach(checkbox => {
        const contextKey = checkbox.dataset.contextKey;
        const selectElement = mappingContainerElem.querySelector(`.group-mapper[data-context-key="${contextKey}"]`);
        const mappedColumnHeader = selectElement ? selectElement.value : '';
        if (mappedColumnHeader) {
            selectedMappings[contextKey] = mappedColumnHeader;
        }
    });

    if (Object.keys(selectedMappings).length === 0) {
        displayMessage(testFillMessageElem, '<i class="fas fa-info-circle mr-2"></i>No fields selected for test filling or no column mapped.', 'error', true);
        return;
    }

    // Prepare data for the first form "row" based on the first spreadsheet data row
    for (const contextKey in selectedMappings) {
        const mappedColumnHeader = selectedMappings[contextKey];
        const columnIndex = headers.indexOf(mappedColumnHeader);

        if (columnIndex !== -1) {
            const fieldsInThisGroup = groupedFormFields[contextKey];
            const targetField = fieldsInThisGroup[0]; // Target the first instance of this grouped field for test fill
            if (targetField) {
                const value = firstDataRow[columnIndex];
                dataToFillForFirstRow.push({
                    id: targetField.id,
                    value: (value !== undefined && value !== null) ? String(value) : ''
                });
            } else {
                console.warn(`No form field instance found for group "${contextKey}" at form row index 0 for test fill.`);
            }
        }
    }

    if (dataToFillForFirstRow.length === 0) {
        displayMessage(testFillMessageElem, '<i class="fas fa-info-circle mr-2"></i>No data prepared for test filling based on current mappings and first spreadsheet row. Check your mappings.', 'info', true);
        return;
    }

    displayMessage(testFillMessageElem, '<i class="fas fa-spinner fa-spin mr-2"></i>Performing test fill for the first row...', 'info', true);
    if (testFillButtonElem) { // Ensure button exists for autoFill section
        testFillButtonElem.disabled = true;
        testFillButtonElem.innerHTML = 'Testing... <span class="loading-spinner"></span>';
    }


    try {
        const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });
        if (!tab) {
            displayMessage(testFillMessageElem, 'Could not get active tab.', 'error', false);
            return;
        }

        const response = await chrome.tabs.sendMessage(tab.id, {
            action: 'fillBatch',
            dataBatch: dataToFillForFirstRow,
            fillEmptyOnly: fillEmptyOnly
        });

        if (response && response.status === 'success') {
            displayMessage(testFillMessageElem, `<i class="fas fa-check-circle mr-2"></i>Test fill complete! ${response.filledCount} fields filled, ${response.skippedCount} fields skipped for the first row.`, 'success', true);
        } else {
            console.error(`Error during test fill: ${response?.message || 'Unknown error.'}`);
            displayMessage(testFillMessageElem, `<i class="fas fa-exclamation-triangle"></i>Error during test fill: ${response?.message || 'Unknown error.'}`, "error", true);
        }

    } catch (error) {
        console.error("Error during test fill:", error);
        displayMessage(testFillMessageElem, `<i class="fas fa-exclamation-triangle"></i>Error during test fill: ${error.message}.`, 'error', true);
    } finally {
        if (testFillButtonElem) {
            testFillButtonElem.disabled = false;
            testFillButtonElem.innerHTML = '<i class="fas fa-vial mr-2"></i>Test Fill First Row';
        }
    }
}

/**
 * Displays a preview of mapped values for the first data row.
 * @param {string} targetSection - 'autoFill' or 'fullAutomation'.
 */
function previewMappedValues(targetSection) {
    const previewValuesMessageElem = targetSection === 'autoFill' ? previewValuesMessageAutoFill : fullAutomationMessage; // Using fullAutomationMessage for this for now.
    const mappingContainerElem = targetSection === 'autoFill' ? mappingContainerAutoFill : mappingContainerFullAutomation;

    if (!workbook || sheetData.length <= 1) {
        displayMessage(previewValuesMessageElem, '<i class="fas fa-exclamation-triangle mr-2"></i>Please upload a spreadsheet file with data first.', 'error', true);
        return;
    }
    if (Object.keys(groupedFormFields).length === 0) {
        displayMessage(previewValuesMessageElem, '<i class="fas fa-exclamation-triangle mr-2"></i>Please scan for fields on the current tab first.', 'error', true);
        return;
    }

    const firstDataRow = sheetData[1];
    if (!firstDataRow) {
        displayMessage(previewValuesMessageElem, '<i class="fas fa-info-circle mr-2"></i>No data rows found in the spreadsheet for preview.', 'info', true);
        return;
    }

    const selectedMappings = {};
    mappingContainerElem.querySelectorAll('.group-checkbox:checked').forEach(checkbox => {
        const contextKey = checkbox.dataset.contextKey;
        const selectElement = mappingContainerElem.querySelector(`.group-mapper[data-context-key="${contextKey}"]`);
        const mappedColumnHeader = selectElement ? selectElement.value : '';
        if (mappedColumnHeader) {
            selectedMappings[contextKey] = mappedColumnHeader;
        }
    });

    if (Object.keys(selectedMappings).length === 0) {
        displayMessage(previewValuesMessageElem, '<i class="fas fa-info-circle mr-2"></i>No fields selected for preview or no column mapped.', 'info', true);
        return;
    }

    let previewHtml = '<p class="font-semibold mb-2">Preview for First Data Row:</p>';
    previewHtml += '<ul class="list-disc list-inside text-left">';

    let hasPreviewData = false;
    for (const contextKey in selectedMappings) {
        const mappedColumnHeader = selectedMappings[contextKey];
        const columnIndex = headers.indexOf(mappedColumnHeader);

        if (columnIndex !== -1) {
            const fieldsInThisGroup = groupedFormFields[contextKey];
            const targetField = fieldsInThisGroup[0]; // Preview for the first instance of this grouped field
            if (targetField) {
                const value = firstDataRow[columnIndex];
                // Using contextKey as the display name now that instances are hidden
                const displayName = contextKey; 

                previewHtml += `<li><strong>${displayName}</strong> (mapped to "${mappedColumnHeader}"): <code>${(value !== undefined && value !== null) ? String(value) : '[Empty]'}</code></li>`;
                hasPreviewData = true;
            }
        }
    }
    previewHtml += '</ul>';

    if (hasPreviewData) {
        displayMessage(previewValuesMessageElem, previewHtml, 'info', true); // Pass true for raw HTML
    } else {
        displayMessage(previewValuesMessageElem, '<i class="fas fa-info-circle mr-2"></i>No preview data available based on current selections. Select some fields and map columns.', 'info', true);
    }
}


/**
 * Displays a temporary message in a designated message box.
 * @param {HTMLElement} element - The message box element (e.g., scanMessage, fillDataMessage).
 * @param {string} message - The message content (can be HTML if isHtml is true).
 * @param {'success'|'error'|'info'} type - The type of message for styling.
 * @param {boolean} isHtml - If true, message is parsed as HTML; otherwise, as plain text.
 */
function displayMessage(element, message, type, isHtml = false) {
    if (isHtml) {
        element.innerHTML = message;
    } else {
        element.textContent = message;
    }
    // Apply base class and type-specific class
    element.className = `message-box mt-3 ${type === 'success' ? 'message-success' : type === 'error' ? 'message-error' : 'message-info'}`;
    element.classList.remove('hidden');

    // Apply dark mode class based on current body theme
    if (document.documentElement.classList.contains('dark')) { // Apply to html element
        element.classList.add('dark');
    } else {
        element.classList.remove('dark');
    }

    // Set a timeout to hide the message, with a longer duration for preview messages
    const duration = element.id && element.id.includes('previewValuesMessage') ? 10000 : 5000;
    setTimeout(() => {
        element.classList.add('hidden');
        element.innerHTML = ''; // Clear content when hidden
    }, duration);
}

/**
 * Displays a temporary message in the specific fileStatusMessage element.
 * This is a specialized version of displayMessage for the file upload status.
 * @param {string} message - The message content (can be HTML if isHtml is true).
 * @param {'success'|'error'|'info'} type - The type of message for styling.
 * @param {HTMLElement} element - The specific message container element (e.g., fileStatusMessageAutoFill).
 * @param {HTMLElement} messageSpan - The span element inside the container for text (e.g., fileMessageAutoFill).
 * @param {HTMLElement} iconElem - The icon element inside the container (e.g., fileStatusIconAutoFill).
 * @param {boolean} isHtml - If true, message is parsed as HTML; otherwise, as plain text.
 */
function displayFileStatusMessage(message, type, element, messageSpan, iconElem, isHtml = false) {
    if (isHtml) {
        messageSpan.innerHTML = message;
    } else {
        messageSpan.textContent = message;
    }

    element.classList.remove('hidden');
    element.className = 'file-status mt-4'; // Reset class for styling
    element.classList.add(`message-${type}`);

    // Set icon based on message type
    if (type === 'success') {
        iconElem.className = 'fas fa-check-circle text-xl mr-3';
    } else if (type === 'error') {
        iconElem.className = 'fas fa-exclamation-circle text-xl mr-3';
    } else if (type === 'info') {
        iconElem.className = 'fas fa-spinner fa-spin text-xl mr-3';
    }

    // Apply dark mode class if body is dark
    if (document.documentElement.classList.contains('dark')) { // Apply to html element
        element.classList.add('dark');
    } else {
        element.classList.remove('dark');
    }

    // Hide after 5 seconds (standard duration for file status)
    setTimeout(() => {
        element.classList.add('hidden');
        messageSpan.innerHTML = ''; // Clear content when hidden
        iconElem.className = ''; // Clear icon
    }, 5000); 
}

/**
 * Initiates the full automation process: clicks "add new finding" then fills data.
 */
async function startFullAutomation() {
    // Reference elements for full automation section
    const messageElem = fullAutomationMessage;
    const buttonElem = startFullAutomationButton;
    const mappingContainerElem = mappingContainerFullAutomation;
    const fillEmptyOnlyCheckboxElem = fillEmptyOnlyCheckboxFullAutomation;

    // 1. Initial Checks and UI State
    if (!workbook || sheetData.length <= 1) {
        displayMessage(messageElem, '<i class="fas fa-exclamation-triangle mr-2"></i>Please upload a spreadsheet file with data first.', 'error', true);
        return;
    }
    if (Object.keys(groupedFormFields).length === 0) {
        displayMessage(messageElem, '<i class="fas fa-exclamation-triangle mr-2"></i>Please scan for fields on the current tab first and map them.', 'error', true);
        return;
    }

    // Disable buttons during operation
    buttonElem.disabled = true;
    buttonElem.innerHTML = 'Automating... <span class="loading-spinner"></span>';

    displayMessage(messageElem, '<i class="fas fa-spinner fa-spin mr-2"></i>Starting full automation...', 'info', true);

    // FIX: Use actualNonEmptyDataRowsCount for accurate click calculation
    const actualDataRowsCount = actualNonEmptyDataRowsCount; // Number of non-empty data rows
    if (actualDataRowsCount === 0) {
        displayMessage(messageElem, '<i class="fas fa-info-circle mr-2"></i>No data rows found in the spreadsheet to automate.', 'info', true);
        buttonElem.disabled = false;
        buttonElem.innerHTML = '<i class="fas fa-play mr-2"></i>Start Full Automation';
        return;
    }

    try {
        const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });
        if (!tab) {
            displayMessage(messageElem, 'Could not get active tab.', 'error', false);
            return;
        }

        // Ensure content.js is injected
        const loaded = await isContentScriptLoaded(tab.id);
        if (!loaded) {
            await chrome.scripting.executeScript({
                target: { tabId: tab.id },
                files: ['content.js']
            });
        }

        // 2. Click "Add New Finding" Button (n-1 times where n is actualDataRowsCount)
        const clicksNeeded = actualDataRowsCount - 1; 
        
        if (clicksNeeded > 0) {
            displayMessage(messageElem, `<i class="fas fa-mouse-pointer fa-spin mr-2"></i>Scanning for "Add New Finding" button...`, 'info', true);
            const clickableElementsResponse = await chrome.tabs.sendMessage(tab.id, { action: "scanClickables" });
            const addFindingButton = clickableElementsResponse?.clickables?.find(btn =>
                btn.text.toLowerCase().includes("add new finding")
            );

            if (!addFindingButton) {
                displayMessage(messageElem, '<i class="fas fa-exclamation-triangle mr-2"></i>"Add New Finding" button not found. Please ensure it exists on the page.', 'error', true);
                return;
            }

            displayMessage(messageElem, `<i class="fas fa-hourglass-half fa-spin mr-2"></i>Clicking "Add New Finding" ${clicksNeeded} time(s) to prepare rows...`, 'info', true);
            const clickResponse = await chrome.tabs.sendMessage(tab.id, {
                action: "performClick",
                stableId: addFindingButton.stableId,
                count: clicksNeeded
            });

            if (clickResponse?.status !== "success") {
                displayMessage(messageElem, `<i class="fas fa-exclamation-triangle mr-2"></i>Failed to click "Add New Finding" button: ${clickResponse?.message || 'Unknown error.'}`, 'error', true);
                return;
            }
            displayMessage(messageElem, `<i class="fas fa-check-circle mr-2"></i>Successfully clicked "Add New Finding" ${clicksNeeded} time(s).`, 'success', true);
        } else {
            displayMessage(messageElem, '<i class="fas fa-info-circle mr-2"></i>No additional clicks needed for "Add New Finding".', 'info', true);
        }

        // 3. Re-scan fields after clicks (to get newly added fields)
        displayMessage(messageElem, '<i class="fas fa-sync-alt fa-spin mr-2"></i>Re-scanning page for all fields after adding new rows...', 'info', true);
        const scanFieldsResponse = await chrome.tabs.sendMessage(tab.id, { action: 'scanFields' });

        if (!scanFieldsResponse || !scanFieldsResponse.fields) {
            displayMessage(messageElem, '<i class="fas fa-exclamation-triangle mr-2"></i>Failed to re-scan fields after clicking. Cannot proceed with data filling.', 'error', true);
            return;
        }

        availableFormFields = scanFieldsResponse.fields;
        groupedFormFields = groupFieldsBySignature(availableFormFields);
        displayMessage(messageElem, `<i class="fas fa-check-circle mr-2"></i>Found ${availableFormFields.length} fields on the page.`, 'success', true);

        // 4. Collect selected mappings from the UI (which should be updated by setupFieldMapping/autoMapFields)
        const selectedMappings = {};
        mappingContainerElem.querySelectorAll('.group-checkbox:checked').forEach(checkbox => {
            const contextKey = checkbox.dataset.contextKey;
            const selectElement = mappingContainerElem.querySelector(`.group-mapper[data-context-key="${contextKey}"]`);
            const mappedColumnHeader = selectElement ? selectElement.value : '';
            if (mappedColumnHeader) {
                selectedMappings[contextKey] = mappedColumnHeader;
            }
        });

        if (Object.keys(selectedMappings).length === 0) {
            displayMessage(messageElem, '<i class="fas fa-info-circle mr-2"></i>No fields selected for filling or no column mapped to selected groups. Please review the "Map Fields" section.', 'error', true);
            return;
        }

        // 5. Prepare and Fill Data for ALL rows
        const dataBatch = [];
        const fillEmptyOnly = fillEmptyOnlyCheckboxElem.checked; 

        sheetData.slice(1).forEach((spreadsheetRow, rowIndex) => { // Iterate through all data rows (excluding header)
            // Ensure we only process up to the actual number of non-empty data rows
            if (rowIndex >= actualDataRowsCount) {
                return; // Skip if this row is beyond the actual non-empty data rows
            }
            for (const contextKey in selectedMappings) {
                const mappedColumnHeader = selectedMappings[contextKey];
                const columnIndex = headers.indexOf(mappedColumnHeader);

                if (columnIndex !== -1) {
                    const fieldsInThisGroup = groupedFormFields[contextKey];
                    // Target the Nth instance for the Nth spreadsheet row.
                    // This is crucial for filling dynamically created form "rows".
                    const targetField = fieldsInThisGroup[rowIndex]; 
                    if (targetField) {
                        const value = spreadsheetRow[columnIndex];
                        dataBatch.push({
                            id: targetField.id,
                            value: (value !== undefined && value !== null) ? String(value) : ''
                        });
                    } else {
                        console.warn(`No form field instance found for group "${contextKey}" at form row index ${rowIndex}. This spreadsheet row might not have a corresponding form field instance.`);
                        displayMessage(messageElem, `<i class="fas fa-exclamation-triangle mr-2"></i>Warning: Form field instance for group "${contextKey}" at row ${rowIndex + 1} not found. Some data might not be filled.`, 'error', false);
                    }
                }
            }
        });

        if (dataBatch.length === 0) {
            displayMessage(messageElem, '<i class="fas fa-info-circle mr-2"></i>No data prepared for filling based on current mappings and spreadsheet data. Check your mappings and file content.', 'info', true);
            return;
        }

        displayMessage(messageElem, `<i class="fas fa-paper-plane fa-spin mr-2"></i>Sending ${dataBatch.length} fields for filling across ${actualDataRowsCount} rows...`, 'info', true);

        const fillResponse = await chrome.tabs.sendMessage(tab.id, {
            action: 'fillBatch',
            dataBatch: dataBatch,
            fillEmptyOnly: fillEmptyOnly
        });

        if (fillResponse && fillResponse.status === 'success') {
            displayMessage(messageElem, `<i class="fas fa-check-circle mr-2"></i>Full automation complete! ${fillResponse.filledCount} fields filled, ${fillResponse.skippedCount} fields skipped.`, 'success', true);
            saveLearnedMappings(); // Save successful mappings
        } else {
            console.error(`Error during data filling: ${fillResponse?.message || 'Unknown error.'}`);
            displayMessage(messageElem, `<i class="fas fa-exclamation-triangle"></i>Error during data filling: ${fillResponse?.message || 'Unknown error.'}`, "error", true);
        }

    } catch (error) {
        console.error("Error during full automation:", error);
        displayMessage(messageElem, `<i class="fas fa-exclamation-triangle"></i>Error during full automation: ${error.message}.`, 'error', true);
    } finally {
        buttonElem.disabled = false;
        buttonElem.innerHTML = '<i class="fas fa-play mr-2"></i>Start Full Automation';
    }
}
--- END FILE: popup.js ---